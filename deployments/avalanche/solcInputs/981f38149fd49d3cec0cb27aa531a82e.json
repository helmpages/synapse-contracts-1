{
  "language": "Solidity",
  "sources": {
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/router/helper/test/TestUniswapAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAdapter} from \"../../interfaces/IAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\ninterface IUniswapV2Router {\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ncontract TestUniswapAdapter {\n    using SafeERC20 for IERC20;\n\n    IUniswapV2Router private router;\n\n    constructor(address _routerAddress) {\n        router = IUniswapV2Router(_routerAddress);\n    }\n\n    function testSwap(\n        address _adapterAddress,\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        bool _checkUnderQuoting,\n        uint256 _iteration\n    ) external {\n        IAdapter adapter = IAdapter(_adapterAddress);\n\n        address depositAddress = adapter.depositAddress(_tokenIn, _tokenOut);\n        if (depositAddress == address(0)) {\n            console.log(\"Swap # %s\", _iteration);\n            console.log(\"Swap not found for %s %s\", _tokenIn, _tokenOut);\n            revert(\"Swap not found\");\n        }\n\n        IERC20(_tokenIn).safeTransferFrom(\n            msg.sender,\n            depositAddress,\n            _amountIn\n        );\n\n        uint256 amountQuoted = adapter.query(_amountIn, _tokenIn, _tokenOut);\n\n        checkAmountQuoted(\n            _amountIn,\n            _tokenIn,\n            _tokenOut,\n            amountQuoted,\n            _iteration\n        );\n\n        uint256 amountSwapped = adapter.swap(\n            _amountIn,\n            _tokenIn,\n            _tokenOut,\n            address(this)\n        );\n        uint256 amountReceived = IERC20(_tokenOut).balanceOf(address(this));\n\n        if (amountSwapped != amountReceived) {\n            console.log(\"Swap # %s\", _iteration);\n            console.log(\n                \"swap: Expected %s, got %s\",\n                amountSwapped,\n                amountReceived\n            );\n            revert(\"swap() failed to return amount of tokens\");\n        }\n\n        if (\n            amountQuoted > amountReceived ||\n            (amountQuoted < amountReceived && _checkUnderQuoting)\n        ) {\n            console.log(\"Swap # %s\", _iteration);\n            if (amountQuoted > amountReceived) {\n                console.log(\n                    \"swap: (over)Quoted %s, got %s (diff: %s)\",\n                    amountQuoted,\n                    amountReceived,\n                    amountQuoted - amountReceived\n                );\n            } else {\n                console.log(\n                    \"swap: (under)Quoted %s, got %s (diff: %s)\",\n                    amountQuoted,\n                    amountReceived,\n                    amountReceived - amountQuoted\n                );\n            }\n            revert(\"query() failed to provide a good quote\");\n        }\n\n        IERC20(_tokenOut).safeTransfer(msg.sender, amountReceived);\n    }\n\n    function checkAmountQuoted(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountQuoted,\n        uint256 _iteration\n    ) internal view {\n        address[] memory path = new address[](2);\n        path[0] = _tokenIn;\n        path[1] = _tokenOut;\n        uint256[] memory _amountsOut = router.getAmountsOut(_amountIn, path);\n        uint256 _amountOut = _amountsOut[1];\n        if (_amountOut != _amountQuoted) {\n            console.log(\"Swap # %s\", _iteration);\n            if (_amountQuoted > _amountOut) {\n                console.log(\n                    \"swap: (over)Quoted %s, actually %s (diff: %s)\",\n                    _amountQuoted,\n                    _amountOut,\n                    _amountQuoted - _amountOut\n                );\n            } else {\n                console.log(\n                    \"swap: (under)Quoted %s, actually %s (diff: %s)\",\n                    _amountQuoted,\n                    _amountOut,\n                    _amountOut - _amountQuoted\n                );\n            }\n            revert(\"query() failed to provide a good quote\");\n        }\n    }\n}\n"
    },
    "contracts/router/interfaces/IAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6;\n\ninterface IAdapter {\n    event UpdatedGasEstimate(address indexed adapter, uint256 newEstimate);\n\n    event Recovered(address indexed asset, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function swapGasEstimate() external view returns (uint256);\n\n    function depositAddress(address tokenIn, address tokenOut)\n        external\n        view\n        returns (address);\n\n    function swap(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        address to\n    ) external returns (uint256);\n\n    function query(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint256);\n}\n"
    },
    "@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20 as _IERC20} from \"@openzeppelin/contracts-solc8/token/ERC20/IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 is _IERC20 {\n    function nonces(address) external view returns (uint256); // Only tokens that support permit\n\n    function permit(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint8,\n        bytes32,\n        bytes32\n    ) external; // Only tokens that support permit\n\n    function mint(address to, uint256 amount) external; // only tokens that support minting\n}\n"
    },
    "@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts-solc8/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n    unchecked {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n        uint256 newAllowance = oldAllowance - value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-solc8/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-solc8/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/vault/wrapper/GmxBridgeWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport {MintBurnWrapper} from \"./MintBurnWrapper.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\ninterface IGmx is IERC20 {\n    function burn(address _account, uint256 _amount) external;\n\n    function mint(address _account, uint256 _amount) external;\n}\n\ncontract GmxBridgeWrapper is MintBurnWrapper {\n    using SafeERC20 for IGmx;\n\n    constructor(\n        address _bridge,\n        address _vault,\n        address _gmx\n    ) MintBurnWrapper(_bridge, _vault, \"GMX (Synapse)\", \"synGMX\", _gmx) {\n        this;\n    }\n\n    /// @dev This will require GmxBridgeWrapper to be Minter for GMX. Don't ask why.\n    function _burnFrom(address account, uint256 amount)\n        internal\n        virtual\n        override\n    {\n        IGmx(nativeToken).burn(account, amount);\n    }\n\n    /// @dev This will require GmxBridgeWrapper to be Minter for GMX.\n    function _mint(address to, uint256 amount) internal virtual override {\n        IGmx(nativeToken).mint(to, amount);\n    }\n}\n"
    },
    "contracts/vault/wrapper/MintBurnWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport {IMintBurnWrapper} from \"../interfaces/IMintBurnWrapper.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\ninterface IERC20Decimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\n/**\n    @dev This contract is used as a bridge mint-burn token on chains where \n         native (underlying) token is not directly compatible with Synapse:Bridge.\n         A way to perform 1:1 \"swap\" between MintBurnWrapper and nativeToken has to exist.\n\n    Here's the list of all contracts that will be interacting with MintBurnWrapper.\n\n                    Getting MintBurnWrapper as parameter:\n    1. Bridge\n                Externally:\n        1. mint [as token] -> _mint(token)\n        2. mintAndSwapV2 [as token] -> _mint(token); _handleSwap(token)\n        3. redeem(Max) [as token] -> _redeem(token); _getMaxAmount(token)\n        4. redeemV2(Max) [as token] -> _redeemV2(token); _getMaxAmount(token)\n        5. redeem(Max)AndSwapV2 [as token] -> _redeemAndSwapV2(token); _getMaxAmount(token)\n\n                Internally:\n        (1) _mint [as token] -> Vault.mintToken(token)\n        (2) _handleSwap [as token] -> BridgeRouter.refundToAddress(token)\n            (swapParams.path[0] would be underlying token)\n        3. _redeem(AndSwap)(V2) [as token] -> _burnFromSender(token)\n        [4] _burnFromSender [as token] -> token.balanceOf(); token.burnFrom()\n        [5] _getMaxAmount [as token] -> token.balanceOf(); token.allowance()\n\n    2. Vault\n                Externally:\n        [1] mintToken [as token] -> fees[token]; token.mint()\n        [2] withdrawFees [as token] -> fees[token]; token.transfer()\n\n    3. BridgeRouter\n                Externally:\n        1. refundToAddress [as token] -> _getUnderlyingToken(token)\n\n                Internally:\n        1. _getUnderlyingToken [as token] -> read underlyingTokens[token]\n        (2) _callBridge [as _getBridgeToken] -> _setBridgeTokenAllowance(_bridgeToken); \n                                                Bridge.redeemMax(AndSwapV2) [as token]\n        3. _setBridgeTokenAllowance [as _bridgeToken] -> _setTokenAllowance(_bridgeToken)\n        [4] _setTokenAllowance [as token] -> token.allowance(); token.approve()\n\n            Summary on token functions calls:\n    1. allowance: Bridge, BridgeRouter\n    2. approve: BridgeRouter\n    3. burnFrom: Bridge\n    4. mint: Vault\n    5. transfer: Vault\n\n*/\nabstract contract MintBurnWrapper is IMintBurnWrapper {\n    /**\n        @dev This contract is supposed to provide following functionality:\n        1. Burn `nativeToken` from arbitrary address, when {burnFrom} is called. By default Bridge.redeem() will be only \n        called by BridgeRouter, so setting up infinite approval for `nativeToken` on BridgeRouter might be needed.\n\n        2. Mint `nativeToken` to arbitrary address, when asked by Vault. This usually requires minting rights on the `nativeToken`\n\n        3. Transfer `nativeToken` from Vault, when Vault.withdrawFees(MintBurnWrapper) is called. Vault knows nothing about wrapping,\n        so all Vault's `nativeToken` are actually stored in this contract (see {balanceOf}). This enables transfer without Vault having\n        to set up token allowances (which Vault isn't supposed to do).\n\n        Other functions are complimentary and take care that all interactions (see list above) are working as expected.\n     */\n    using SafeERC20 for IERC20;\n\n    address public immutable bridge;\n    address public immutable vault;\n\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /// @notice address of native (underlying) token\n    address public immutable nativeToken;\n\n    constructor(\n        address _bridge,\n        address _vault,\n        string memory _name,\n        string memory _symbol,\n        address _nativeToken\n    ) {\n        bridge = _bridge;\n        vault = _vault;\n        name = _name;\n        symbol = _symbol;\n        decimals = IERC20Decimals(_nativeToken).decimals();\n        nativeToken = _nativeToken;\n    }\n\n    modifier onlyBridge() {\n        require(msg.sender == bridge, \"Caller is not Bridge\");\n\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == bridge, \"Caller is not Vault\");\n\n        _;\n    }\n\n    /**\n        @notice Get maximum amount of native tokens `spender` can burn from `owner` \n        via {burnFrom}.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n        @notice Sets `amount` as maximum amount of tokens `spender` can burn from caller.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        return true;\n    }\n\n    /**\n        @notice Returns the `account` balance of native tokens. This is required for \n        external validation of {mint} and {burnFrom}, as well as for getting the max amount of \n        native tokens can be burnt via {burnFrom}.\n     */\n    function balanceOf(address account)\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        // Remember, native tokens from Vault are stored here\n        if (account == vault) {\n            return IERC20(nativeToken).balanceOf(address(this));\n        } else {\n            return IERC20(nativeToken).balanceOf(account);\n        }\n    }\n\n    /**\n        @notice Burns native tokens from `account`, within the approved allowance.\n        @dev Only Bridge is able to call this function (see the list of interactions above).\n        This, and the requirement for approving, makes it impossible to call {burnFrom} without bridging the tokens.\n     */\n    function burnFrom(address account, uint256 amount) external onlyBridge {\n        require(\n            _allowances[account][msg.sender] >= amount,\n            \"Can't burn more than allowance\"\n        );\n        _allowances[account][msg.sender] -= amount;\n        uint256 balanceBefore = IERC20(nativeToken).balanceOf(account);\n\n        _burnFrom(account, amount);\n\n        uint256 balanceAfter = IERC20(nativeToken).balanceOf(account);\n        // Verify the burn, so Bridge doesn't have to trust burn implementation\n        require(balanceBefore == amount + balanceAfter, \"Burn is incomplete\");\n    }\n\n    /**\n        @notice Mints native tokens to account.\n        @dev Only Vault is able to call this function (see the list of interactions above).\n        This makes it impossible to mint tokens without having valid proof of bridging (see Vault).\n     */\n    function mint(address to, uint256 amount) external onlyVault {\n        if (to == bridge) {\n            // Don't mint native tokens to Vault, mint to this address instead\n            to = address(this);\n        }\n        uint256 balanceBefore = IERC20(nativeToken).balanceOf(to);\n\n        _mint(to, amount);\n\n        uint256 balanceAfter = IERC20(nativeToken).balanceOf(to);\n        // Verify the burn, so Vault doesn't have to trust mint implementation\n        require(balanceBefore + amount == balanceAfter, \"Mint is incomplete\");\n    }\n\n    /**\n        @notice Sends native tokens from caller to account.\n        @dev Only Vault is supposed to call this function when the bridge fees are\n        being withdrawn.\n     */\n    function transfer(address to, uint256 amount) external onlyVault {\n        uint256 balanceBefore = IERC20(nativeToken).balanceOf(to);\n        _transfer(to, amount);\n\n        uint256 balanceAfter = IERC20(nativeToken).balanceOf(to);\n        require(\n            balanceBefore + amount == balanceAfter,\n            \"Transfer is incomplete\"\n        );\n    }\n\n    /// @dev This should burn native token from account.\n    /// Will only be called by Bridge\n    function _burnFrom(address account, uint256 amount) internal virtual;\n\n    /// @dev This should mint native token to account.\n    /// Will only be called by Vault\n    function _mint(address to, uint256 amount) internal virtual;\n\n    /// @dev This should transfer native token from caller to account.\n    /// Will only be called by Vault, no allowance is required\n    function _transfer(address to, uint256 amount) internal virtual {\n        IERC20(nativeToken).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/vault/interfaces/IMintBurnWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IMintBurnWrapper {\n    // -- VIEWS --\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function nativeToken() external view returns (address);\n\n    // -- STATE CHANGING --\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function burnFrom(address account, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n\n    function transfer(address to, uint256 amount) external;\n}\n"
    },
    "contracts/vault/wrapper/DepositBridgeWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport {MintBurnWrapper} from \"./MintBurnWrapper.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\ncontract DepositBridgeWrapper is MintBurnWrapper {\n    /**\n        @dev This contract wraps deposit-withdraw interaction, so from outside perspective\n        it looks like a mint-burn token.\n        NOTE: this doesn't actually mint tokens, so use with caution, as the \"mint\" capacity\n        is restrained by amount of previously deposited tokens\n     */\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _bridge,\n        address _vault,\n        string memory _name,\n        string memory _symbol,\n        address _depositToken\n    ) MintBurnWrapper(_bridge, _vault, _name, _symbol, _depositToken) {\n        this;\n    }\n\n    /**\n        @dev {burnFrom} is called when bridging via redeem-like function on Bridge.\n\n        Full support for bridging using BridgeRouter can be achieved by doing \n        BridgeRouter.setInfiniteTokenAllowance(depositToken, DepositBridgeWrapper).\n\n        Users willing to bridge via Bridge directly (but why?) will need to pre-approve \n        DepositBridgeWrapper to spend their depositToken.\n     */\n    function _burnFrom(address account, uint256 amount)\n        internal\n        virtual\n        override\n    {\n        IERC20(nativeToken).safeTransferFrom(account, address(this), amount);\n    }\n\n    function _mint(address to, uint256 amount) internal virtual override {\n        IERC20(nativeToken).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/vault/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable-solc8/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable-solc8/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable-solc8/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable-solc8/security/PausableUpgradeable.sol\";\n\nimport {ERC20Burnable} from \"@openzeppelin/contracts-solc8/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IBridge} from \"./interfaces/IBridge.sol\";\nimport {IBridgeConfig} from \"./interfaces/IBridgeConfig.sol\";\n\nimport {IBridgeRouter} from \"../router/interfaces/IBridgeRouter.sol\";\n\n// solhint-disable reason-string\n\ncontract Bridge is\n    Initializable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    IBridge\n{\n    using SafeERC20 for IERC20;\n\n    IBridgeConfig public bridgeConfig;\n    IBridgeRouter public router;\n    IVault public vault;\n\n    bytes32 public constant NODEGROUP_ROLE = keccak256(\"NODEGROUP_ROLE\");\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n\n    /// @notice Maximum amount of GAS units for Swap part of bridge transaction\n    uint256 public maxGasForSwap;\n\n    uint256 internal constant UINT_MAX = type(uint256).max;\n\n    function initialize(\n        IVault _vault,\n        IBridgeConfig _bridgeConfig,\n        uint256 _maxGasForSwap\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        vault = _vault;\n        bridgeConfig = _bridgeConfig;\n        maxGasForSwap = _maxGasForSwap;\n    }\n\n    // -- MODIFIERS --\n\n    modifier checkSwapParams(SwapParams calldata swapParams) {\n        require(\n            swapParams.path.length == swapParams.adapters.length + 1,\n            \"|path|!=|adapters|+1\"\n        );\n\n        _;\n    }\n\n    // -- RECOVER TOKEN/GAS --\n\n    /**\n        @notice Recover GAS from the contract\n     */\n    function recoverGAS() external onlyRole(GOVERNANCE_ROLE) {\n        uint256 amount = address(this).balance;\n        require(amount != 0, \"!balance\");\n\n        emit Recovered(address(0), amount);\n        //solhint-disable-next-line\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"!xfer\");\n    }\n\n    /**\n        @notice Recover a token from the contract\n        @param token token to recover\n     */\n    function recoverERC20(IERC20 token) external onlyRole(GOVERNANCE_ROLE) {\n        uint256 amount = token.balanceOf(address(this));\n        require(amount != 0, \"!balance\");\n\n        emit Recovered(address(token), amount);\n        //solhint-disable-next-line\n        token.safeTransfer(msg.sender, amount);\n    }\n\n    // -- RESTRICTED SETTERS --\n\n    function setMaxGasForSwap(uint256 _maxGasForSwap)\n        external\n        onlyRole(GOVERNANCE_ROLE)\n    {\n        maxGasForSwap = _maxGasForSwap;\n    }\n\n    function setRouter(IBridgeRouter _router)\n        external\n        onlyRole(GOVERNANCE_ROLE)\n    {\n        router = _router;\n    }\n\n    // -- BRIDGE OUT FUNCTIONS: to EVM chains --\n\n    function bridgeToEVM(\n        address to,\n        uint256 chainId,\n        IERC20 token,\n        SwapParams calldata destinationSwapParams,\n        bool gasdropRequested\n    )\n        external\n        checkSwapParams(destinationSwapParams)\n        returns (uint256 amountBridged)\n    {\n        // First, get token address on destination chain and check if it is enabled\n        (address tokenBridgedTo, bool isEnabled) = bridgeConfig\n            .getTokenAddressEVM(address(token), chainId);\n\n        require(tokenBridgedTo != address(0), \"!token\");\n        require(isEnabled, \"!isEnabled\");\n        require(tokenBridgedTo == destinationSwapParams.path[0], \"!swap\");\n\n        // Then, burn token, or deposit to Vault (depending on bridge token type).\n        // Use verified burnt/deposited amount for bridging purposes.\n        amountBridged = _lockToken(token);\n\n        // Finally, emit a Bridge Event\n        emit BridgedOutEVM(\n            to,\n            chainId,\n            token,\n            amountBridged,\n            IERC20(tokenBridgedTo),\n            destinationSwapParams,\n            gasdropRequested\n        );\n    }\n\n    // -- BRIDGE OUT FUNCTIONS: to non-EVM chain --\n\n    function bridgeToNonEVM(\n        bytes32 to,\n        uint256 chainId,\n        IERC20 token\n    ) external returns (uint256 amountBridged) {\n        // First, get token address on destination chain and check if it is enabled\n        (string memory tokenBridgedTo, bool isEnabled) = bridgeConfig\n            .getTokenAddressNonEVM(address(token), chainId);\n        require(bytes(tokenBridgedTo).length > 0, \"!token\");\n        require(isEnabled, \"!isEnabled\");\n\n        // Then, burn token, or deposit to Vault (depending on bridge token type).\n        // Use verified burnt/deposited amount for bridging purposes.\n        amountBridged = _lockToken(token);\n\n        // Finally, emit a Bridge Event\n        emit BridgedOutNonEVM(\n            to,\n            chainId,\n            token,\n            amountBridged,\n            tokenBridgedTo\n        );\n    }\n\n    // -- BRIDGE OUT : internal helpers --\n\n    function _lockToken(IERC20 token)\n        internal\n        returns (uint256 amountVerified)\n    {\n        // Figure out how much tokens do we have.\n        uint256 amount = token.balanceOf(address(this));\n        require(amount > 0, \"!amount\");\n\n        (address bridgeToken, bool isEnabled, bool isMintBurn) = bridgeConfig\n            .getBridgeToken(address(token));\n\n        require(isEnabled, \"!enabled\");\n\n        if (isMintBurn) {\n            // Burn token, and verify how much was burnt\n            uint256 balanceBefore = token.balanceOf(address(this));\n\n            ERC20Burnable(bridgeToken).burn(amount);\n\n            amountVerified = balanceBefore - token.balanceOf(address(this));\n        } else {\n            // Deposit token into Vault, and verify how much was burnt\n            uint256 balanceBefore = token.balanceOf(address(vault));\n\n            IERC20(bridgeToken).transfer(address(vault), amount);\n\n            amountVerified = token.balanceOf(address(vault)) - balanceBefore;\n        }\n\n        require(amountVerified > 0, \"!locked\");\n    }\n\n    // -- BRIDGE IN FUNCTIONS --\n\n    function bridgeInEVM(\n        address to,\n        IERC20 token,\n        uint256 amount,\n        SwapParams calldata swapParams,\n        bool gasdropRequested,\n        bytes32 kappa\n    ) external onlyRole(NODEGROUP_ROLE) nonReentrant whenNotPaused {\n        _bridgeIn(to, token, amount, swapParams, gasdropRequested, kappa);\n    }\n\n    function bridgeInNonEVM(\n        address to,\n        uint256 chainIdFrom,\n        string calldata bridgeTokenFrom,\n        uint256 amount,\n        bytes32 kappa\n    ) external onlyRole(NODEGROUP_ROLE) nonReentrant whenNotPaused {\n        address token = bridgeConfig.findTokenNonEVM(\n            chainIdFrom,\n            bridgeTokenFrom\n        );\n        require(token != address(0), \"!token\");\n\n        // Construct path consisting of bridge token only (for consistency)\n        address[] memory path = new address[](1);\n        path[0] = token;\n\n        _bridgeIn(\n            to,\n            IERC20(token),\n            amount,\n            // (minAmountOut, path, adapters, deadline)\n            SwapParams(0, path, new address[](0), UINT_MAX),\n            // gasdropEnabled = true\n            true,\n            kappa\n        );\n    }\n\n    function _bridgeIn(\n        address to,\n        IERC20 token,\n        uint256 amount,\n        SwapParams memory swapParams,\n        bool gasdropRequested,\n        bytes32 kappa\n    ) internal {\n        _BridgeInData memory data;\n        // solhint-disable not-rely-on-time\n        data.amountOfSwaps = block.timestamp <= swapParams.deadline\n            ? swapParams.adapters.length\n            : 0;\n\n        (data.fee, data.bridgeToken, data.isEnabled, data.isMint) = bridgeConfig\n            .calculateBridgeFee(\n                address(token),\n                amount,\n                gasdropRequested,\n                data.amountOfSwaps\n            );\n\n        require(amount > data.fee, \"!fee\");\n        require(data.isEnabled, \"!enabled\");\n\n        // First, get the amount post fees\n        amount = amount - data.fee;\n\n        // If swap is present, release tokens to Router directly\n        // Otherwise, release them to specified user address\n        data.gasdropAmount = _releaseToken(\n            data.amountOfSwaps > 0 ? address(router) : to,\n            data.bridgeToken,\n            amount,\n            data.fee,\n            data.isMint,\n            to, // always send gasDrop to user\n            gasdropRequested,\n            kappa\n        );\n\n        // If swap is present, do it and gather the info about tokens received\n        // Otherwise, use bridge token and its amount\n        (data.tokenReceived, data.amountReceived) = data.amountOfSwaps > 0\n            ? _handleSwap(to, token, amount, swapParams)\n            : (token, amount);\n\n        // Finally, emit BridgeIn Event\n        emit TokenBridgedIn(\n            to,\n            token,\n            amount + data.fee,\n            data.fee,\n            data.tokenReceived,\n            data.amountReceived,\n            data.gasdropAmount,\n            kappa\n        );\n    }\n\n    // -- BRIDGE IN: internal helpers --\n\n    function _handleSwap(\n        address to,\n        IERC20 token,\n        uint256 amountPostFee,\n        SwapParams memory swapParams\n    ) internal returns (IERC20 tokenOut, uint256 amountOut) {\n        // We're limiting amount of gas forwarded to Router,\n        // so we always have some leftover gas to transfer\n        // bridged token, should the swap run out of gas\n        try\n            router.postBridgeSwap{gas: maxGasForSwap}(\n                to,\n                swapParams,\n                amountPostFee\n            )\n        returns (uint256 _amountOut) {\n            // Swap succeeded, save information about received token\n            tokenOut = IERC20(swapParams.path[swapParams.path.length - 1]);\n            amountOut = _amountOut;\n        } catch {\n            // Swap failed, return bridge token to user\n            tokenOut = token;\n            amountOut = amountPostFee;\n            router.refundToAddress(to, token, amountPostFee);\n        }\n    }\n\n    function _isSwapPresent(SwapParams memory params)\n        internal\n        pure\n        returns (bool)\n    {\n        return params.adapters.length > 0;\n    }\n\n    function _releaseToken(\n        address to,\n        address bridgeToken,\n        uint256 amountPostFee,\n        uint256 fee,\n        bool isMint,\n        address userAddress,\n        bool gasdropRequested,\n        bytes32 kappa\n    ) internal returns (uint256 gasdropAmount) {\n        gasdropAmount = (isMint ? vault.mintToken : vault.withdrawToken)(\n            to,\n            IERC20(bridgeToken),\n            amountPostFee,\n            fee,\n            userAddress,\n            gasdropRequested,\n            kappa\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-solc8/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/vault/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ninterface IVault {\n    // -- VIEWS --\n\n    function chainGasAmount() external returns (uint256);\n\n    function getFeeBalance(address tokenAddress)\n        external\n        view\n        returns (uint256);\n\n    function getTokenBalance(IERC20 token) external view returns (uint256);\n\n    function kappaExists(bytes32 kappa) external view returns (bool);\n\n    // solhint-disable-next-line\n    function WETH_ADDRESS() external returns (address payable);\n\n    // -- VAULT FUNCTIONS --\n\n    function mintToken(\n        address to,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        address gasdropAddress,\n        bool gasdropRequested,\n        bytes32 kappa\n    ) external returns (uint256 gasdropAmount);\n\n    function withdrawToken(\n        address to,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        address gasdropAddress,\n        bool gasdropRequested,\n        bytes32 kappa\n    ) external returns (uint256 gasdropAmount);\n}\n"
    },
    "contracts/vault/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.11;\n\nimport {ERC20Burnable} from \"@openzeppelin/contracts-solc8/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\nimport {IVault} from \"./IVault.sol\";\nimport {IBridgeConfig} from \"./IBridgeConfig.sol\";\n\nimport {IBridgeRouter} from \"../../router/interfaces/IBridgeRouter.sol\";\n\ninterface IBridge {\n    // internal struct to avoid stack too deep error\n    // solhint-disable-next-line\n    struct _BridgeInData {\n        address bridgeToken;\n        uint256 fee;\n        uint256 amountOfSwaps;\n        bool isEnabled;\n        bool isMint;\n        uint256 gasdropAmount;\n        IERC20 tokenReceived;\n        uint256 amountReceived;\n    }\n\n    struct SwapParams {\n        uint256 minAmountOut;\n        address[] path;\n        address[] adapters;\n        uint256 deadline;\n    }\n\n    event Recovered(address indexed asset, uint256 amount);\n\n    // -- VIEWS --\n\n    function bridgeConfig() external view returns (IBridgeConfig);\n\n    function router() external view returns (IBridgeRouter);\n\n    function vault() external view returns (IVault);\n\n    // -- BRIDGE EVENTS OUT:\n\n    event BridgedOutEVM(\n        address indexed to,\n        uint256 chainId,\n        IERC20 tokenBridgedFrom,\n        uint256 amount,\n        IERC20 tokenBridgedTo,\n        SwapParams swapParams,\n        bool gasdropRequested\n    );\n\n    event BridgedOutNonEVM(\n        bytes32 indexed to,\n        uint256 chainId,\n        IERC20 tokenBridgedFrom,\n        uint256 amount,\n        string tokenBridgedTo\n    );\n\n    // -- BRIDGE EVENTS IN --\n\n    event TokenBridgedIn(\n        address indexed to,\n        IERC20 tokenBridged,\n        uint256 amountBridged,\n        uint256 bridgeFee,\n        IERC20 tokenReceived,\n        uint256 amountReceived,\n        uint256 gasdropAmount,\n        bytes32 indexed kappa\n    );\n\n    // -- BRIDGE OUT FUNCTIONS:\n\n    function bridgeToEVM(\n        address to,\n        uint256 chainId,\n        IERC20 token,\n        SwapParams calldata destinationSwapParams,\n        bool gasdropRequested\n    ) external returns (uint256 amountBridged);\n\n    function bridgeToNonEVM(\n        bytes32 to,\n        uint256 chainId,\n        IERC20 token\n    ) external returns (uint256 amountBridged);\n\n    // -- BRIDGE IN FUNCTIONS --\n\n    function bridgeInEVM(\n        address to,\n        IERC20 token,\n        uint256 amount,\n        SwapParams calldata destinationSwapParams,\n        bool gasdropRequested,\n        bytes32 kappa\n    ) external;\n\n    function bridgeInNonEVM(\n        address to,\n        uint256 chainIdFrom,\n        string calldata bridgeTokenFrom,\n        uint256 amount,\n        bytes32 kappa\n    ) external;\n}\n"
    },
    "contracts/vault/interfaces/IBridgeConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.11;\n\ninterface IBridgeConfig {\n    /// @dev UNKNOWN would be default value\n    enum TokenType {\n        UNKNOWN,\n        MINT_BURN,\n        DEPOSIT_WITHDRAW\n    }\n\n    struct TokenConfig {\n        // ------------------------------------ TOKEN SETUP ---------------------------------------\n        /// @notice Describes how `token` is going to be bridged: mint or withdraw\n        TokenType tokenType;\n        /// @notice Contract responsible for `token` locking/releasing.\n        /// @dev If `token` is compatible with Synapse:Bridge directly, this would be `token` address.\n        /// Otherwise, it is address of BridgeWrapper for `token`.\n        /// No one (UI, users, validators) needs to know about this extra layer, it is abstracted away\n        /// outside of Bridge contract.\n        address bridgeToken;\n        /// @notice Whether bridging is enabled for given token\n        bool isEnabled;\n        // ------------------------------------ FEES ----------------------------------------------\n        /// @notice Synapse:bridge fee value(i.e. 0.1%), multiplied by `FEE_DENOMINATOR`\n        uint256 synapseFee;\n        /// @notice Maximum total bridge fee\n        uint256 maxTotalFee;\n        /// @notice Minimum part of the fee covering bridging in (always present)\n        uint256 minBridgeFee;\n        /// @notice Minimum part of the fee covering GasDrop (when gasDrop is present)\n        uint256 minGasDropFee;\n        /// @notice Minimum part of the fee covering further swap (when swap is present)\n        uint256 minSwapFee;\n        // ------------------------------------ MAP INFO ------------------------------------------\n        /// @dev If `token` comes from non-EVM chain, these will store the token config on non-EVM chain.\n        /// Otherwise, these are left empty.\n        uint256 chainIdNonEVM;\n        string bridgeTokenNonEVM;\n        /// @dev List of ALL EVM chains `token` is present on, in no particular order.\n        /// This includes the chain this Bridge is deployed on\n        uint256[] chainIdsEVM;\n    }\n\n    // -- SINGLE CHAIN SETUP EVENTS --\n\n    event TokenSetupUpdated(\n        address token,\n        address bridgeToken,\n        bool isMintBurn\n    );\n\n    event TokenFeesUpdated(\n        address token,\n        uint256 synapseFee,\n        uint256 maxTotalFee,\n        uint256 minBridgeFee,\n        uint256 minGasDropFee,\n        uint256 minSwapFee\n    );\n\n    // -- CROSS CHAIN SETUP EVENTS --\n\n    event TokenDeleted(uint256 chainIdEVM, address bridgeTokenEVM);\n\n    event TokenMapUpdated(\n        uint256[] chainIdsEVM,\n        address[] bridgeTokensEVM,\n        uint256 chainIdNonEVM,\n        string bridgeTokenNonEVM\n    );\n\n    event TokenStatusUpdated(\n        uint256[] chainIdsEVM,\n        address[] bridgeTokensEVM,\n        bool isEnabled\n    );\n\n    // -- VIEWS --\n\n    function calculateBridgeFee(\n        address token,\n        uint256 amount,\n        bool gasdropRequested,\n        uint256 amountOfSwaps\n    )\n        external\n        view\n        returns (\n            uint256 fee,\n            address bridgeToken,\n            bool isEnabled,\n            bool isMintBurn\n        );\n\n    function getAllBridgeTokensEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, address[] memory tokensGlobal);\n\n    function getAllBridgeTokensNonEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, string[] memory tokensGlobal);\n\n    function getBridgeToken(address token)\n        external\n        view\n        returns (\n            address bridgeToken,\n            bool isEnabled,\n            bool isMintBurn\n        );\n\n    function getTokenAddressEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (address tokenGlobal, bool isEnabled);\n\n    function getTokenAddressNonEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (string memory tokenGlobal, bool isEnabled);\n\n    function findTokenEVM(uint256 chainId, address tokenGlobal)\n        external\n        view\n        returns (address tokenLocal);\n\n    function findTokenNonEVM(uint256 chainId, string calldata tokenGlobal)\n        external\n        view\n        returns (address tokenLocal);\n\n    function isTokenEnabled(address bridgeToken) external view returns (bool);\n}\n"
    },
    "contracts/router/interfaces/IBridgeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IRouter} from \"./IRouter.sol\";\nimport {IBridge} from \"../../vault/interfaces/IBridge.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ninterface IBridgeRouter is IRouter {\n    // -- VIEWS --\n\n    function bridgeMaxSwaps() external view returns (uint8);\n\n    function bridge() external view returns (address);\n\n    // -- SETTERS --\n\n    function setBridgeMaxSwaps(uint8 bridgeMaxSwaps) external;\n\n    // -- BRIDGE FUNCTIONS [initial chain]: to EVM chains --\n\n    function bridgeTokenToEVM(\n        address to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams,\n        uint256 amountIn,\n        IBridge.SwapParams calldata destinationSwapParams,\n        bool gasdropRequested\n    ) external returns (uint256 amountBridged);\n\n    function bridgeGasToEVM(\n        address to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams,\n        IBridge.SwapParams calldata destinationSwapParams,\n        bool gasdropRequested\n    ) external payable returns (uint256 amountBridged);\n\n    // -- BRIDGE FUNCTIONS [initial chain]: to non-EVM chains --\n\n    function bridgeTokenToNonEVM(\n        bytes32 to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams,\n        uint256 amountIn\n    ) external returns (uint256 amountBridged);\n\n    function bridgeGasToNonEVM(\n        bytes32 to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams\n    ) external payable returns (uint256 amountBridged);\n\n    // -- BRIDGE FUNCTIONS [destination chain] --\n\n    function refundToAddress(\n        address to,\n        IERC20 token,\n        uint256 amount\n    ) external;\n\n    function postBridgeSwap(\n        address to,\n        IBridge.SwapParams calldata swapParams,\n        uint256 amountIn\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable-solc8/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-solc8/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts-solc8/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-solc8/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/router/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBasicRouter} from \"./IBasicRouter.sol\";\n\ninterface IRouter is IBasicRouter {\n    event Swap(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    // Single chain swaps\n\n    function swap(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapFromGAS(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function swapToGAS(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/router/interfaces/IBasicRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ninterface IBasicRouter {\n    event Recovered(address indexed asset, uint256 amount);\n\n    event AddedTrustedAdapter(address newTrustedAdapter);\n\n    event RemovedAdapter(address removedAdapter);\n\n    event UpdatedAdapters(address[] adapters, bool isTrusted);\n\n    // -- VIEWS --\n\n    function isTrustedAdapter(address adapter) external view returns (bool);\n\n    // solhint-disable-next-line\n    function WGAS() external view returns (address payable);\n\n    // -- ADAPTER FUNCTIONS --\n\n    function addTrustedAdapter(address adapter) external;\n\n    function removeAdapter(address adapter) external;\n\n    function setAdapters(address[] memory adapters, bool status) external;\n\n    // -- RECOVER FUNCTIONS --\n\n    function recoverERC20(IERC20 token) external;\n\n    function recoverGAS() external;\n\n    // -- RECEIVE GAS FUNCTION --\n\n    receive() external payable;\n}\n"
    },
    "contracts/router/BridgeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBridgeRouter} from \"./interfaces/IBridgeRouter.sol\";\n\nimport {ERC20Burnable} from \"@openzeppelin/contracts-solc8/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport {IBridge} from \"../vault/interfaces/IBridge.sol\";\n\nimport {Router} from \"./Router.sol\";\n\n// solhint-disable reason-string\n\ncontract BridgeRouter is Router, IBridgeRouter {\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of Synapse: Bridge contract\n    address public immutable bridge;\n\n    /// @notice Maximum amount of swaps for Bridge&Swap transaction\n    /// It is enforced to limit the gas costs for validators on \"expensive\" chains\n    /// There's no extra limitation for Swap&Bridge txs, as the gas is paid by the user\n    uint8 public bridgeMaxSwaps;\n\n    constructor(\n        address payable _wgas,\n        address _bridge,\n        uint8 _bridgeMaxSwaps\n    ) Router(_wgas) {\n        bridge = _bridge;\n        setBridgeMaxSwaps(_bridgeMaxSwaps);\n    }\n\n    modifier onlyBridge() {\n        require(msg.sender == bridge, \"Caller is not Bridge\");\n\n        _;\n    }\n\n    modifier checkSwapParams(IBridge.SwapParams calldata swapParams) {\n        require(\n            swapParams.path.length == swapParams.adapters.length + 1,\n            \"BridgeRouter: len(path)!=len(adapters)+1\"\n        );\n\n        _;\n    }\n\n    // -- RESTRICTED SETTERS --\n\n    function setBridgeMaxSwaps(uint8 _bridgeMaxSwaps)\n        public\n        onlyRole(GOVERNANCE_ROLE)\n    {\n        bridgeMaxSwaps = _bridgeMaxSwaps;\n    }\n\n    // -- BRIDGE FUNCTIONS [initial chain]: to EVM chains --\n\n    function bridgeTokenToEVM(\n        address to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams,\n        uint256 amountIn,\n        IBridge.SwapParams calldata destinationSwapParams,\n        bool gasdropRequested\n    )\n        external\n        deadlineCheck(initialSwapParams.deadline)\n        returns (uint256 amountBridged)\n    {\n        // First, perform swap on initial chain\n        // Need to pull tokens from caller => isSelfSwap = false\n        IERC20 bridgeToken = _swapToBridge(initialSwapParams, amountIn, false);\n\n        // Then, perform bridging\n        amountBridged = IBridge(bridge).bridgeToEVM(\n            to,\n            chainId,\n            bridgeToken,\n            destinationSwapParams,\n            gasdropRequested\n        );\n    }\n\n    function bridgeGasToEVM(\n        address to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams,\n        IBridge.SwapParams calldata destinationSwapParams,\n        bool gasdropRequested\n    )\n        external\n        payable\n        deadlineCheck(initialSwapParams.deadline)\n        returns (uint256 amountBridged)\n    {\n        // TODO: enforce consistency?? introduce amountIn parameter\n\n        require(\n            initialSwapParams.path.length > 0 &&\n                initialSwapParams.path[0] == WGAS,\n            \"Router: path needs to begin with WGAS\"\n        );\n\n        // First, wrap GAS into WGAS\n        _wrap(msg.value);\n\n        // Then, perform swap on initial chain\n        // Tokens(WGAS) are in the contract => isSelfSwap = true\n        IERC20 bridgeToken = _swapToBridge(initialSwapParams, msg.value, true);\n\n        // Finally, perform bridging\n        amountBridged = IBridge(bridge).bridgeToEVM(\n            to,\n            chainId,\n            bridgeToken,\n            destinationSwapParams,\n            gasdropRequested\n        );\n    }\n\n    // -- BRIDGE FUNCTIONS [initial chain]: to non-EVM chains --\n\n    function bridgeTokenToNonEVM(\n        bytes32 to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams,\n        uint256 amountIn\n    )\n        external\n        deadlineCheck(initialSwapParams.deadline)\n        returns (uint256 amountBridged)\n    {\n        // First, perform swap on initial chain\n        // Need to pull tokens from caller => isSelfSwap = false\n        IERC20 bridgeToken = _swapToBridge(initialSwapParams, amountIn, false);\n\n        // Then, perform bridging\n        amountBridged = IBridge(bridge).bridgeToNonEVM(\n            to,\n            chainId,\n            bridgeToken\n        );\n    }\n\n    function bridgeGasToNonEVM(\n        bytes32 to,\n        uint256 chainId,\n        IBridge.SwapParams calldata initialSwapParams\n    )\n        external\n        payable\n        deadlineCheck(initialSwapParams.deadline)\n        returns (uint256 amountBridged)\n    {\n        // TODO: enforce consistency?? introduce amountIn parameter\n\n        require(\n            initialSwapParams.path.length > 0 &&\n                initialSwapParams.path[0] == WGAS,\n            \"Router: path needs to begin with WGAS\"\n        );\n\n        // First, wrap GAS into WGAS\n        _wrap(msg.value);\n\n        // Then, perform swap on initial chain\n        // Tokens(WGAS) are in the contract => isSelfSwap = true\n        IERC20 bridgeToken = _swapToBridge(initialSwapParams, msg.value, true);\n\n        // Finally, perform bridging\n        amountBridged = IBridge(bridge).bridgeToNonEVM(\n            to,\n            chainId,\n            bridgeToken\n        );\n    }\n\n    // -- BRIDGE FUNCTIONS [initial chain]: internal helpers\n\n    function _swapToBridge(\n        IBridge.SwapParams calldata initialSwapParams,\n        uint256 amountIn,\n        bool isSelfSwap\n    ) internal checkSwapParams(initialSwapParams) returns (IERC20 lastToken) {\n        if (_isSwapPresent(initialSwapParams)) {\n            // Swap, and send swapped tokens to Bridge contract directly\n            (isSelfSwap ? _selfSwap : _swap)(\n                bridge,\n                initialSwapParams.path,\n                initialSwapParams.adapters,\n                amountIn,\n                initialSwapParams.minAmountOut\n            );\n\n            lastToken = _getLastToken(initialSwapParams);\n        } else {\n            // checkSwapParams() checked that path.length == 1\n            lastToken = IERC20(initialSwapParams.path[0]);\n\n            if (isSelfSwap) {\n                // Tokens are in the contract, send them to Bridge\n                lastToken.transfer(bridge, amountIn);\n            } else {\n                // If tokens aren't in the contract, we need to send them from caller to Bridge\n                lastToken.safeTransferFrom(msg.sender, bridge, amountIn);\n            }\n        }\n    }\n\n    // -- BRIDGE RELATED FUNCTIONS [destination chain] --\n\n    /**\n        @notice refund tokens from unsuccessful swap back to user\n        @dev This will return native GAS to user, if token = WGAS, so calling contract\n             needs to check for reentrancy.\n        @param token token to refund\n        @param amount amount of tokens to refund\n        @param to address to receive refund tokens\n     */\n    function refundToAddress(\n        address to,\n        IERC20 token,\n        uint256 amount\n    ) external onlyBridge {\n        // We don't check for reentrancy here as all the work is done\n\n        // BUT Bridge contract might want to check\n        // for reentrancy when calling refundToAddress()\n        // Imagine [Bridge GAS & Swap] back to its native chain.\n        // If swap fails, this unwrap WGAS and return GAS to user\n\n        _returnTokensTo(to, token, amount);\n    }\n\n    /**\n        @notice Perform a series of swaps, assuming the starting tokens\n                are already deposited in this contract\n        @dev 1. This will revert if amount of adapters is too big, \n                bridgeMaxSwaps is usually lower than MAX_SWAPS\n             2. Use BridgeQuoter.findBestPathDestinationChain() to correctly \n                find path with len(_adapters) <= bridgeMaxSwaps\n             3. len(_path) = N, len(_adapters) = N - 1\n        @param amountIn amount of initial tokens to swap\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function postBridgeSwap(\n        address to,\n        IBridge.SwapParams calldata swapParams,\n        uint256 amountIn\n    ) external onlyBridge returns (uint256 amountOut) {\n        require(\n            swapParams.adapters.length <= bridgeMaxSwaps,\n            \"BridgeRouter: Too many swaps in path\"\n        );\n        if (address(_getLastToken(swapParams)) == WGAS) {\n            // Path ends with WGAS, and no one wants\n            // to receive WGAS after bridging, right?\n            amountOut = _selfSwap(\n                address(this),\n                swapParams.path,\n                swapParams.adapters,\n                amountIn,\n                swapParams.minAmountOut\n            );\n            // this will unwrap WGAS and return GAS\n            // reentrancy not an issue here, as all work is done\n            _returnTokensTo(to, IERC20(WGAS), amountOut);\n        } else {\n            amountOut = _selfSwap(\n                to,\n                swapParams.path,\n                swapParams.adapters,\n                amountIn,\n                swapParams.minAmountOut\n            );\n        }\n    }\n\n    // -- INTERNAL HELPERS --\n\n    function _getLastToken(IBridge.SwapParams calldata swapParams)\n        internal\n        pure\n        returns (IERC20 lastToken)\n    {\n        lastToken = IERC20(swapParams.path[swapParams.path.length - 1]);\n    }\n\n    function _isSwapPresent(IBridge.SwapParams calldata swapParams)\n        internal\n        pure\n        returns (bool)\n    {\n        return swapParams.adapters.length > 0;\n    }\n}\n"
    },
    "contracts/router/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAdapter} from \"./interfaces/IAdapter.sol\";\nimport {IRouter} from \"./interfaces/IRouter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport {BasicRouter} from \"./BasicRouter.sol\";\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts-4.4.2/security/ReentrancyGuard.sol\";\n\n// solhint-disable reason-string\n\ncontract Router is ReentrancyGuard, BasicRouter, IRouter {\n    using SafeERC20 for IERC20;\n\n    constructor(address payable _wgas) BasicRouter(_wgas) {\n        this;\n    }\n\n    modifier deadlineCheck(uint256 deadline) {\n        // solhint-disable-next-line\n        require(block.timestamp <= deadline, \"Router: past deadline\");\n\n        _;\n    }\n\n    // -- SWAPPERS [single chain swaps] --\n\n    /**\n        @notice Perform a series of swaps along the token path, using the provided Adapters\n        @dev 1. Tokens will be pulled from msg.sender, so make sure Router has enough allowance to \n                spend initial token. \n             2. Use Quoter.getTradeDataAmountOut() -> _tradeData to find best route with preset slippage.\n             3. len(path) = N, len(adapters) = N - 1\n        @param amountIn amount of initial tokens to swap\n        @param minAmountOut minimum amount of final tokens for a swap to be successful\n        @param path token path for the swap, path[0] = initial token, path[N - 1] = final token\n        @param adapters adapters that will be used for swap. adapters[i]: swap path[i] -> path[i + 1]\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function swap(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) external deadlineCheck(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(to, path, adapters, amountIn, minAmountOut);\n    }\n\n    /**\n        @notice Perform a series of swaps along the token path, starting with\n                chain's native currency (GAS), using the provided Adapters.\n        @dev 1. Make sure to set amountIn = msg.value, path[0] = WGAS\n             2. Use Quoter.getTradeDataAmountOut() -> _tradeData to find best route with preset slippage.\n             3. len(path) = N, len(adapters) = N - 1\n        @param amountIn amount of initial tokens to swap\n        @param minAmountOut minimum amount of final tokens for a swap to be successful\n        @param path token path for the swap, path[0] = initial token, path[N - 1] = final token\n        @param adapters adapters that will be used for swap. adapters[i]: swap path[i] -> path[i + 1]\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function swapFromGAS(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) external payable deadlineCheck(deadline) returns (uint256 amountOut) {\n        require(msg.value == amountIn, \"Router: incorrect amount of GAS\");\n        require(path[0] == WGAS, \"Router: Path needs to begin with WGAS\");\n        _wrap(amountIn);\n        // WGAS tokens need to be sent from this contract\n        amountOut = _selfSwap(to, path, adapters, amountIn, minAmountOut);\n    }\n\n    /**\n        @notice Perform a series of swaps along the token path, ending with\n                chain's native currency (GAS), using the provided Adapters.\n        @dev 1. Tokens will be pulled from msg.sender, so make sure Router has enough allowance to \n                spend initial token.\n             2. Make sure to set path[N-1] = WGAS\n             3. Address to needs to be able to accept native GAS\n             4. Use Quoter.getTradeDataAmountOut() -> _tradeData to find best route with preset slippage.\n             5. len(path) = N, len(adapters) = N - 1\n        @param amountIn amount of initial tokens to swap\n        @param minAmountOut minimum amount of final tokens for a swap to be successful\n        @param path token path for the swap, path[0] = initial token, path[N - 1] = final token\n        @param adapters adapters that will be used for swap. adapters[i]: swap path[i] -> path[i + 1]\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function swapToGAS(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 deadline\n    ) external deadlineCheck(deadline) returns (uint256 amountOut) {\n        require(\n            path[path.length - 1] == WGAS,\n            \"Router: Path needs to end with WGAS\"\n        );\n        // This contract needs to receive WGAS in order to unwrap it\n        amountOut = _swap(\n            address(this),\n            path,\n            adapters,\n            amountIn,\n            minAmountOut\n        );\n        // this will unwrap WGAS and return GAS\n        // reentrancy not an issue here, as all work is done\n        _returnTokensTo(to, IERC20(WGAS), amountOut);\n    }\n\n    // -- INTERNAL SWAP FUNCTIONS --\n\n    /// @dev All internal swap functions have a reentrancy guard\n\n    /**\n        @notice Pull tokens from msg.sender and perform a series of swaps\n        @dev Use _selfSwap if tokens are already in the contract\n             Don't do this: _from = address(this);\n        @param amountIn amount of initial tokens to swap\n        @param minAmountOut minimum amount of final tokens for a swap to be successful\n        @param path token path for the swap, path[0] = initial token, path[N - 1] = final token\n        @param adapters adapters that will be used for swap. adapters[i]: swap path[i] -> path[i + 1]\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function _swap(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal nonReentrant returns (uint256 amountOut) {\n        require(path.length > 1, \"Router: path too short\");\n        address tokenIn = path[0];\n        address tokenNext = path[1];\n        IERC20(tokenIn).safeTransferFrom(\n            msg.sender,\n            _getDepositAddress(adapters[0], tokenIn, tokenNext),\n            amountIn\n        );\n\n        amountOut = _doChainedSwaps(to, path, adapters, amountIn, minAmountOut);\n    }\n\n    /**\n        @notice Perform a series of swaps, assuming the starting tokens\n                are already deposited in this contract\n        @param amountIn amount of initial tokens to swap\n        @param minAmountOut minimum amount of final tokens for a swap to be successful\n        @param path token path for the swap, path[0] = initial token, path[N - 1] = final token\n        @param adapters adapters that will be used for swap. adapters[i]: swap path[i] -> path[i + 1]\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function _selfSwap(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal nonReentrant returns (uint256 amountOut) {\n        require(path.length > 1, \"Router: path too short\");\n        address tokenIn = path[0];\n        address tokenNext = path[1];\n        IERC20(tokenIn).safeTransfer(\n            _getDepositAddress(adapters[0], tokenIn, tokenNext),\n            amountIn\n        );\n\n        amountOut = _doChainedSwaps(to, path, adapters, amountIn, minAmountOut);\n    }\n\n    struct ChainedSwapData {\n        address tokenIn;\n        address tokenOut;\n        address tokenNext;\n        IAdapter adapterNext;\n        address targetAddress;\n    }\n\n    /**\n        @notice Perform a series of swaps, assuming the starting tokens\n                have already been deposited in the first adapter\n        @param amountIn amount of initial tokens to swap\n        @param minAmountOut minimum amount of final tokens for a swap to be successful\n        @param path token path for the swap, path[0] = initial token, path[N - 1] = final token\n        @param adapters adapters that will be used for swap. adapters[i]: swap path[i] -> path[i + 1]\n        @param to address to receive final tokens\n        @return amountOut Final amount of tokens swapped\n     */\n    function _doChainedSwaps(\n        address to,\n        address[] calldata path,\n        address[] calldata adapters,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        require(\n            path.length == adapters.length + 1,\n            \"Router: wrong amount of adapters/tokens\"\n        );\n        require(to != address(0), \"Router: to cannot be zero address\");\n        for (uint256 i = 0; i < adapters.length; ++i) {\n            require(isTrustedAdapter[adapters[i]], \"Router: unknown adapter\");\n        }\n\n        // yo mama's too deep\n        ChainedSwapData memory data;\n        data.tokenOut = path[0];\n        data.tokenNext = path[1];\n        data.adapterNext = IAdapter(adapters[0]);\n\n        amountOut = IERC20(path[path.length - 1]).balanceOf(to);\n\n        for (uint256 i = 0; i < adapters.length; ++i) {\n            data.tokenIn = data.tokenOut;\n            data.tokenOut = data.tokenNext;\n\n            IAdapter adapter = data.adapterNext;\n            if (i < adapters.length - 1) {\n                data.adapterNext = IAdapter(adapters[i + 1]);\n                data.tokenNext = path[i + 2];\n                data.targetAddress = data.adapterNext.depositAddress(\n                    data.tokenOut,\n                    data.tokenNext\n                );\n            } else {\n                data.targetAddress = to;\n            }\n\n            amountIn = adapter.swap(\n                amountIn,\n                data.tokenIn,\n                data.tokenOut,\n                data.targetAddress\n            );\n        }\n        // figure out how much tokens user received exactly\n        amountOut = IERC20(data.tokenOut).balanceOf(to) - amountOut;\n        require(\n            amountOut >= minAmountOut,\n            \"Router: Insufficient output amount\"\n        );\n        emit Swap(path[0], data.tokenOut, amountIn, amountOut);\n    }\n\n    // -- INTERNAL HELPERS\n\n    /**\n        @notice Get selected adapter's deposit address\n        @dev Return value of address(0) means that adapter\n             doesn't support this pair of tokens, thus revert\n        @param adapter Adapter in question\n        @param tokenIn token to sell\n        @param tokenOut token to buy\n     */\n    function _getDepositAddress(\n        address adapter,\n        address tokenIn,\n        address tokenOut\n    ) internal view returns (address depositAddress) {\n        depositAddress = IAdapter(adapter).depositAddress(tokenIn, tokenOut);\n        require(depositAddress != address(0), \"Adapter: unknown tokens\");\n    }\n}\n"
    },
    "contracts/router/BasicRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBasicRouter} from \"./interfaces/IBasicRouter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {IWETH9} from \"@synapseprotocol/sol-lib/contracts/universal/interfaces/IWETH9.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport {AccessControl} from \"@openzeppelin/contracts-4.4.2/access/AccessControl.sol\";\n\ncontract BasicRouter is AccessControl, IBasicRouter {\n    using SafeERC20 for IERC20;\n\n    /// @notice Members of this role can add/remove trusted Adapters\n    bytes32 public constant ADAPTERS_STORAGE_ROLE =\n        keccak256(\"ADAPTERS_STORAGE_ROLE\");\n\n    /// @notice Members of this role can rescue funds from this contract\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n\n    /// @dev This is address of contract representing\n    /// wrapped ERC20 version of a chain's native currency (ex. WETH, WAVAX, WMOVR)\n    // solhint-disable-next-line\n    address payable public immutable WGAS;\n\n    mapping(address => bool) public isTrustedAdapter;\n\n    uint256 internal constant UINT_MAX = type(uint256).max;\n\n    constructor(address payable _wgas) {\n        WGAS = _wgas;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(GOVERNANCE_ROLE, msg.sender);\n    }\n\n    // -- RECEIVE GAS --\n\n    receive() external payable {\n        // silence linter\n        this;\n    }\n\n    // -- RESTRICTED ADAPTER FUNCTIONS --\n\n    function addTrustedAdapter(address adapter)\n        external\n        onlyRole(ADAPTERS_STORAGE_ROLE)\n    {\n        isTrustedAdapter[adapter] = true;\n        emit AddedTrustedAdapter(adapter);\n    }\n\n    function removeAdapter(address adapter)\n        external\n        onlyRole(ADAPTERS_STORAGE_ROLE)\n    {\n        isTrustedAdapter[adapter] = false;\n        emit RemovedAdapter(adapter);\n    }\n\n    function setAdapters(address[] calldata adapters, bool status)\n        external\n        onlyRole(ADAPTERS_STORAGE_ROLE)\n    {\n        for (uint8 i = 0; i < adapters.length; ++i) {\n            isTrustedAdapter[adapters[i]] = status;\n        }\n        emit UpdatedAdapters(adapters, status);\n    }\n\n    // -- RESTRICTED RECOVER TOKEN FUNCTIONS --\n\n    function recoverERC20(IERC20 token) external onlyRole(GOVERNANCE_ROLE) {\n        uint256 amount = token.balanceOf(address(this));\n        require(amount > 0, \"Adapter: Nothing to recover\");\n\n        emit Recovered(address(token), amount);\n        token.safeTransfer(msg.sender, amount);\n    }\n\n    function recoverGAS() external onlyRole(GOVERNANCE_ROLE) {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"Adapter: Nothing to recover\");\n\n        emit Recovered(address(0), amount);\n        //solhint-disable-next-line\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"GAS transfer failed\");\n    }\n\n    // -- INTERNAL HELPERS --\n\n    /**\n     * @notice Return tokens to user\n     *\n     * @dev Pass WGAS address to unwrap it and return GAS to user\n     *      Make sure to either \n            1. Return WGAS as last operation to avoid reentrancy issues\n            2. Add nonReentrant modifier otherwise\n     *\n     * @param token address\n     * @param amount tokens to return\n     * @param to address where funds should be sent to\n     */\n    function _returnTokensTo(\n        address to,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        if (address(this) != to) {\n            if (address(token) == WGAS) {\n                _unwrap(amount);\n                // solhint-disable-next-line\n                (bool success, ) = to.call{value: amount}(\"\");\n                require(success, \"GAS transfer failed\");\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function _wrap(uint256 amount) internal {\n        IWETH9(WGAS).deposit{value: amount}();\n    }\n\n    function _unwrap(uint256 amount) internal {\n        IWETH9(WGAS).withdraw(amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@synapseprotocol/sol-lib/contracts/universal/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\npragma experimental ABIEncoderV2;\n\ninterface IWETH9 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n\n    receive() external payable;\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n}"
    },
    "@openzeppelin/contracts-4.4.2/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/router/BasicQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBasicQuoter} from \"./interfaces/IBasicQuoter.sol\";\nimport {IBasicRouter} from \"./interfaces/IBasicRouter.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts-4.4.2/access/Ownable.sol\";\nimport {Bytes} from \"@synapseprotocol/sol-lib/contracts/universal/lib/LibBytes.sol\";\n\ncontract BasicQuoter is Ownable, IBasicQuoter {\n    /// @notice A list of tokens that will be used as \"intermediate\" tokens, when\n    /// finding the best path between initial and final token\n    address[] internal trustedTokens;\n\n    /// @notice A list of adapters that are abstracting away swaps via third party contracts\n    address[] internal trustedAdapters;\n\n    /// @notice Maximum amount of swaps that Quoter will be using\n    /// for finding the best path between two tokens.\n    /// This is done for two reasons:\n    /// 1. Too many swaps in the path make very little sense\n    /// 2. Every extra swap increases the amount of possible paths exponentially,\n    ///    so we need some sensible limitation.\n    // solhint-disable-next-line\n    uint8 public MAX_SWAPS;\n\n    address payable public immutable router;\n\n    constructor(address payable _router, uint8 _maxSwaps) {\n        setMaxSwaps(_maxSwaps);\n        router = _router;\n    }\n\n    // -- MODIFIERS --\n\n    modifier checkTokenIndex(uint8 index) {\n        require(index < trustedTokens.length, \"Token index out of range\");\n        _;\n    }\n\n    modifier checkAdapterIndex(uint8 index) {\n        require(index < trustedAdapters.length, \"Adapter index out of range\");\n        _;\n    }\n\n    //  -- VIEWS --\n\n    function getTrustedAdapter(uint8 index)\n        external\n        view\n        checkAdapterIndex(index)\n        returns (address)\n    {\n        return trustedAdapters[index];\n    }\n\n    function getTrustedToken(uint8 index)\n        external\n        view\n        checkTokenIndex(index)\n        returns (address)\n    {\n        return trustedTokens[index];\n    }\n\n    function trustedAdaptersCount() external view returns (uint256) {\n        return trustedAdapters.length;\n    }\n\n    function trustedTokensCount() external view returns (uint256) {\n        return trustedTokens.length;\n    }\n\n    // -- RESTRICTED ADAPTER FUNCTIONS --\n\n    function addTrustedAdapter(address adapter) external onlyOwner {\n        for (uint8 i = 0; i < trustedAdapters.length; i++) {\n            require(trustedAdapters[i] != adapter, \"Adapter already added\");\n        }\n        trustedAdapters.push(adapter);\n        // Add Adapter to Router as well\n        IBasicRouter(router).addTrustedAdapter(adapter);\n        emit AddedTrustedAdapter(adapter);\n    }\n\n    function removeAdapter(address adapter) external onlyOwner {\n        for (uint8 i = 0; i < trustedAdapters.length; i++) {\n            if (trustedAdapters[i] == adapter) {\n                _removeAdapterByIndex(i);\n                return;\n            }\n        }\n        revert(\"Adapter not found\");\n    }\n\n    function removeAdapterByIndex(uint8 index) external onlyOwner {\n        _removeAdapterByIndex(index);\n    }\n\n    // -- RESTRICTED TOKEN FUNCTIONS --\n\n    function addTrustedToken(address token) external onlyOwner {\n        for (uint8 i = 0; i < trustedTokens.length; i++) {\n            require(trustedTokens[i] != token, \"Token already added\");\n        }\n        trustedTokens.push(token);\n        emit AddedTrustedToken(token);\n    }\n\n    function removeToken(address token) external onlyOwner {\n        for (uint8 i = 0; i < trustedTokens.length; i++) {\n            if (trustedTokens[i] == token) {\n                _removeTokenByIndex(i);\n                return;\n            }\n        }\n        revert(\"Token not found\");\n    }\n\n    function removeTokenByIndex(uint8 index) external onlyOwner {\n        _removeTokenByIndex(index);\n    }\n\n    // -- RESTRICTED SETTERS\n\n    /// @dev This doesn't check if any of the adapters are duplicated,\n    /// so make sure to check the data for duplicates\n    function setAdapters(address[] calldata adapters) external onlyOwner {\n        // First, remove old Adapters, if there are any\n        if (trustedAdapters.length > 0) {\n            IBasicRouter(router).setAdapters(trustedAdapters, false);\n        }\n        trustedAdapters = adapters;\n        IBasicRouter(router).setAdapters(adapters, true);\n        emit UpdatedTrustedAdapters(adapters);\n    }\n\n    function setMaxSwaps(uint8 _maxSwaps) public onlyOwner {\n        MAX_SWAPS = _maxSwaps;\n    }\n\n    /// @dev This doesn't check if any of the tokens are duplicated,\n    /// so make sure to check the data for duplicates\n    function setTokens(address[] calldata tokens) public onlyOwner {\n        trustedTokens = tokens;\n        emit UpdatedTrustedTokens(tokens);\n    }\n\n    // -- PRIVATE FUNCTIONS --\n\n    function _removeAdapterByIndex(uint8 index)\n        private\n        checkAdapterIndex(index)\n    {\n        address removedAdapter = trustedAdapters[index];\n\n        // We don't care about adapters order, so we replace the\n        // selected adapter with the last one\n        trustedAdapters[index] = trustedAdapters[trustedAdapters.length - 1];\n        trustedAdapters.pop();\n\n        // Remove Adapter from Router as well\n        IBasicRouter(router).removeAdapter(removedAdapter);\n\n        emit RemovedAdapter(removedAdapter);\n    }\n\n    function _removeTokenByIndex(uint8 index) private checkTokenIndex(index) {\n        address removedToken = trustedTokens[index];\n\n        // We don't care about tokens order, so we replace the\n        // selected token with the last one\n        trustedTokens[index] = trustedTokens[trustedTokens.length - 1];\n        trustedTokens.pop();\n\n        emit RemovedToken(removedToken);\n    }\n}\n"
    },
    "contracts/router/interfaces/IBasicQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBasicQuoter {\n    event UpdatedTrustedAdapters(address[] newTrustedAdapters);\n\n    event AddedTrustedAdapter(address newTrustedAdapter);\n\n    event RemovedAdapter(address removedAdapter);\n\n    event RemovedAdapters(address[] removedAdapters);\n\n    event UpdatedTrustedTokens(address[] newTrustedTokens);\n\n    event AddedTrustedToken(address newTrustedToken);\n\n    event RemovedToken(address removedToken);\n\n    struct Query {\n        address adapter;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountOut;\n    }\n\n    struct Trade {\n        uint256 amountIn;\n        uint256 amountOut;\n        address[] path;\n        address[] adapters;\n    }\n\n    //  -- VIEWS --\n\n    function getTrustedAdapter(uint8 index) external view returns (address);\n\n    function getTrustedToken(uint8 index) external view returns (address);\n\n    function trustedAdaptersCount() external view returns (uint256);\n\n    function trustedTokensCount() external view returns (uint256);\n\n    // -- ADAPTER FUNCTIONS --\n\n    function addTrustedAdapter(address adapter) external;\n\n    function removeAdapter(address adapter) external;\n\n    function removeAdapterByIndex(uint8 index) external;\n\n    // -- TOKEN FUNCTIONS --\n\n    function addTrustedToken(address token) external;\n\n    function removeToken(address token) external;\n\n    function removeTokenByIndex(uint8 index) external;\n\n    // -- SETTERS --\n\n    function setAdapters(address[] calldata adapters) external;\n\n    function setMaxSwaps(uint8 maxSwaps) external;\n\n    function setTokens(address[] memory tokens) external;\n}\n"
    },
    "@synapseprotocol/sol-lib/contracts/universal/lib/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nlibrary Bytes {\n    function toBytes(address x)\n        internal\n        pure\n        returns (bytes memory b)\n    {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n\n    function toAddress(uint _offst, bytes memory _input)\n        internal\n        pure\n        returns (address _output)\n    {\n        assembly { _output := mload(add(_input, _offst)) }\n    }\n\n    function toBytes(uint256 x)\n        internal\n        pure\n        returns (bytes memory b)\n    {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n\n    function toUint256(uint _offst, bytes memory _input)\n        internal\n        pure\n        returns (uint256 _output)\n    {\n        assembly { _output := mload(add(_input, _offst)) }\n    }\n\n    function mergeBytes(bytes memory a, bytes memory b)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        // From https://ethereum.stackexchange.com/a/40456\n        uint alen = a.length;\n        uint totallen = alen + b.length;\n        uint loopsa = (a.length + 31) / 32;\n        uint loopsb = (b.length + 31) / 32;\n        assembly {\n            let m := mload(0x40)\n            mstore(m, totallen)\n            for {  let i := 0 } lt(i, loopsa) { i := add(1, i) } { mstore(add(m, mul(32, add(1, i))), mload(add(a, mul(32, add(1, i))))) }\n            for {  let i := 0 } lt(i, loopsb) { i := add(1, i) } { mstore(add(m, add(mul(32, add(1, i)), alen)), mload(add(b, mul(32, add(1, i))))) }\n            mstore(0x40, add(m, add(32, totallen)))\n            c := m\n        }\n    }\n}\n"
    },
    "contracts/router/Quoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BasicQuoter} from \"./BasicQuoter.sol\";\n\nimport {IAdapter} from \"./interfaces/IAdapter.sol\";\nimport {IQuoter} from \"./interfaces/IQuoter.sol\";\nimport {IBasicRouter} from \"./interfaces/IBasicRouter.sol\";\n\nimport {Offers} from \"./libraries/LibOffers.sol\";\n\nimport {Bytes} from \"@synapseprotocol/sol-lib/contracts/universal/lib/LibBytes.sol\";\n\ncontract Quoter is BasicQuoter, IQuoter {\n    /// @dev Setup flow:\n    /// 1. Create Router contract\n    /// 2. Create Quoter contract\n    /// 3. Give Quoter ADAPTERS_STORAGE_ROLE in Router contract\n    /// 4. Add tokens and adapters\n\n    /// PS. If the migration from one Quoter to another is needed (w/0 changing Router):\n    /// 1. call oldQuoter.setAdapters([]), this will clear the adapters in Router\n    /// 2. revoke ADAPTERS_STORAGE_ROLE from oldQuoter\n    /// 3. Do (2-4) from setup flow as usual\n    constructor(address payable _router, uint8 _maxSwaps)\n        BasicQuoter(_router, _maxSwaps)\n    {\n        this;\n    }\n\n    // -- FIND BEST PATH --\n\n    /**\n        @notice Find the best path between two tokens\n\n        @param amountIn amount of initial tokens to swap\n        @param tokenIn initial token to sell\n        @param tokenOut final token to buy\n        @param maxSwaps maximum amount of swaps in the route between initial and final tokens\n    */\n    function findBestPath(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint8 maxSwaps\n    ) public view returns (Offers.FormattedOffer memory _bestOffer) {\n        require(\n            maxSwaps > 0 && maxSwaps <= MAX_SWAPS,\n            \"Quoter: Invalid max-swaps\"\n        );\n        Offers.Offer memory queries;\n        queries.amounts = Bytes.toBytes(amountIn);\n        queries.path = Bytes.toBytes(tokenIn);\n\n        queries = _findBestPath(amountIn, tokenIn, tokenOut, maxSwaps, queries);\n\n        // If no paths are found, return empty struct\n        if (queries.adapters.length == 0) {\n            queries.amounts = \"\";\n            queries.path = \"\";\n        }\n        return Offers.formatOfferWithGas(queries);\n    }\n\n    // -- INTERNAL HELPERS\n\n    /**\n        @notice Find the best path between two tokens\n        @dev Part of the route is fixed, which is reflected in queries\n             The return value is unformatted byte arrays, use Offers.formatOfferWithGas() to format\n\n        @param amountIn amount of current tokens to swap\n        @param tokenIn current token to sell\n        @param tokenOut final token to buy\n        @param maxSwaps maximum amount of swaps in the route between initial and final tokens\n        @param queries Fixed prefix of the route between initial and final tokens\n        @return bestOption bytes amounts, bytes adapters, bytes path\n     */\n    function _findBestPath(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxSwaps,\n        Offers.Offer memory queries\n    ) internal view returns (Offers.Offer memory) {\n        Offers.Offer memory bestOption = Offers.cloneOfferWithGas(queries);\n        /// @dev bestAmountOut is net returns of the swap,\n        /// this is the parameter that should be maximized\n\n        // bestAmountOut: amount of tokenOut in the local best found route\n\n        // First check if there is a path directly from tokenIn to tokenOut\n        uint256 bestAmountOut = _checkDirectSwap(\n            amountIn,\n            tokenIn,\n            tokenOut,\n            bestOption\n        );\n\n        // Check for swaps through intermediate tokens, only if there are enough swaps left\n        // Need at least two extra swaps\n        if (maxSwaps > 1 && queries.adapters.length / 32 <= maxSwaps - 2) {\n            // Check for paths that pass through trusted tokens\n            for (uint256 i = 0; i < trustedTokens.length; i++) {\n                address trustedToken = trustedTokens[i];\n                // trustedToken == tokenIn  means swap isn't possible\n                // trustedToken == tokenOut was checked above in _checkDirectSwap\n                if (trustedToken == tokenIn || trustedToken == tokenOut) {\n                    continue;\n                }\n                // Loop through all adapters to find the best one\n                // for swapping tokenIn for one of the trusted tokens\n\n                Query memory bestSwap = queryDirectSwap(\n                    amountIn,\n                    tokenIn,\n                    trustedToken\n                );\n                if (bestSwap.amountOut == 0) {\n                    continue;\n                }\n                Offers.Offer memory newOffer = Offers.cloneOfferWithGas(\n                    queries\n                );\n                // add bestSwap to the current route\n                Offers.addQuery(\n                    newOffer,\n                    bestSwap.amountOut,\n                    bestSwap.adapter,\n                    bestSwap.tokenOut\n                );\n                // Find best path, starting with current route + bestSwap\n                // new current token is trustedToken\n                // its amount is bestSwap.amountOut\n                newOffer = _findBestPath(\n                    bestSwap.amountOut,\n                    trustedToken,\n                    tokenOut,\n                    maxSwaps,\n                    newOffer\n                );\n                address lastToken = Bytes.toAddress(\n                    newOffer.path.length,\n                    newOffer.path\n                );\n                // Check that the last token in the path is tokenOut and update the new best option\n                // only if amountOut is increased\n                if (lastToken == tokenOut) {\n                    uint256 newAmountOut = Bytes.toUint256(\n                        newOffer.amounts.length,\n                        newOffer.amounts\n                    );\n\n                    // bestAmountOut == 0 means we don't have the \"best\" option yet\n                    if (bestAmountOut < newAmountOut || bestAmountOut == 0) {\n                        bestAmountOut = newAmountOut;\n                        bestOption = newOffer;\n                    }\n                }\n            }\n        }\n        return bestOption;\n    }\n\n    /**\n        @notice Get the best swap quote using any of the adapters\n        @param amountIn amount of tokens to swap\n        @param tokenIn token to sell\n        @param tokenOut token to buy\n        @return bestQuery Query with best quote available\n     */\n    function queryDirectSwap(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut\n    ) internal view returns (Query memory bestQuery) {\n        for (uint8 i = 0; i < trustedAdapters.length; ++i) {\n            address adapter = trustedAdapters[i];\n            uint256 amountOut = IAdapter(adapter).query(\n                amountIn,\n                tokenIn,\n                tokenOut\n            );\n            if (amountOut == 0) {\n                continue;\n            }\n\n            // bestQuery.amountOut == 0 means there's no \"best\" yet\n            if (amountOut > bestQuery.amountOut || bestQuery.amountOut == 0) {\n                bestQuery = Query(adapter, tokenIn, tokenOut, amountOut);\n            }\n        }\n    }\n\n    /**\n        @notice Find the best direct swap between tokens and append it to current Offer\n        @dev Nothing will be appended, if no direct route between tokens is found\n        @param amountIn amount of initial token to swap\n        @param tokenIn current token to sell\n        @param tokenOut final token to buy\n        @param bestOption current Offer to append the found swap\n     */\n    function _checkDirectSwap(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        Offers.Offer memory bestOption\n    ) internal view returns (uint256 amountOut) {\n        Query memory queryDirect = queryDirectSwap(amountIn, tokenIn, tokenOut);\n        if (queryDirect.amountOut != 0) {\n            Offers.addQuery(\n                bestOption,\n                queryDirect.amountOut,\n                queryDirect.adapter,\n                queryDirect.tokenOut\n            );\n            amountOut = queryDirect.amountOut;\n        }\n    }\n}\n"
    },
    "contracts/router/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBasicQuoter} from \"./IBasicQuoter.sol\";\nimport {Offers} from \"../libraries/LibOffers.sol\";\n\ninterface IQuoter is IBasicQuoter {\n    function findBestPath(\n        address tokenIn,\n        uint256 amountIn,\n        address tokenOut,\n        uint8 maxSwaps\n    ) external view returns (Offers.FormattedOffer memory);\n}\n"
    },
    "contracts/router/libraries/LibOffers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Bytes} from \"@synapseprotocol/sol-lib/contracts/universal/lib/LibBytes.sol\";\n\nlibrary Offers {\n    struct Offer {\n        bytes amounts;\n        bytes adapters;\n        bytes path;\n    }\n\n    struct FormattedOffer {\n        uint256[] amounts;\n        address[] adapters;\n        address[] path;\n    }\n\n    /**\n     * Appends Query elements to Offer struct\n     */\n    function addQuery(\n        Offer memory _queries,\n        uint256 _amount,\n        address _adapter,\n        address _tokenOut\n    ) internal pure {\n        _queries.path = Bytes.mergeBytes(\n            _queries.path,\n            Bytes.toBytes(_tokenOut)\n        );\n        _queries.amounts = Bytes.mergeBytes(\n            _queries.amounts,\n            Bytes.toBytes(_amount)\n        );\n        _queries.adapters = Bytes.mergeBytes(\n            _queries.adapters,\n            Bytes.toBytes(_adapter)\n        );\n    }\n\n    /**\n     * Makes a deep copy of Offer struct\n     */\n    function cloneOfferWithGas(Offer memory _queries)\n        internal\n        pure\n        returns (Offer memory)\n    {\n        return Offer(_queries.amounts, _queries.adapters, _queries.path);\n    }\n\n    /**\n     * Converts byte-arrays to an array of integers\n     */\n    function formatAmounts(bytes memory _amounts)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        // Format amounts\n        uint256 chunks = _amounts.length / 32;\n        uint256[] memory amountsFormatted = new uint256[](chunks);\n        for (uint256 i = 0; i < chunks; i++) {\n            amountsFormatted[i] = Bytes.toUint256(i * 32 + 32, _amounts);\n        }\n        return amountsFormatted;\n    }\n\n    /**\n     * Converts byte-array to an array of addresses\n     */\n    function formatAddresses(bytes memory _addresses)\n        internal\n        pure\n        returns (address[] memory)\n    {\n        uint256 chunks = _addresses.length / 32;\n        address[] memory addressesFormatted = new address[](chunks);\n        for (uint256 i = 0; i < chunks; i++) {\n            addressesFormatted[i] = Bytes.toAddress(i * 32 + 32, _addresses);\n        }\n        return addressesFormatted;\n    }\n\n    /**\n     * Formats elements in the Offer object from byte-arrays to integers and addresses\n     */\n    function formatOfferWithGas(Offer memory _queries)\n        internal\n        pure\n        returns (FormattedOffer memory)\n    {\n        return\n            FormattedOffer(\n                formatAmounts(_queries.amounts),\n                formatAddresses(_queries.adapters),\n                formatAddresses(_queries.path)\n            );\n    }\n}\n"
    },
    "contracts/router/interfaces/IBridgeQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IQuoter} from \"./IQuoter.sol\";\nimport {Offers} from \"../libraries/LibOffers.sol\";\n\ninterface IBridgeQuoter is IQuoter {\n    // -- BEST PATH: initial chain --\n\n    function bestPathToBridge(\n        address tokenIn,\n        uint256 amountIn,\n        address bridgeToken\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    function bestPathToBridgeEVM(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 chainId,\n        address bridgeTokenGlobal\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    function bestPathToBridgeNonEVM(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 chainId,\n        string calldata bridgeTokenGlobal\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    // -- BEST PATH: destination chain --\n\n    function bestPathFromBridge(\n        address bridgeToken,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    function bestPathFromBridgeEVM(\n        uint256 chainId,\n        address bridgeTokenGlobal,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    function bestPathFromBridgeNonEVM(\n        uint256 chainIdFrom,\n        string calldata bridgeTokenFrom,\n        uint256 amountIn\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    function bestPathFromBridgeNonEVM(\n        uint256 chainIdFrom,\n        string calldata bridgeTokenFrom,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) external view returns (Offers.FormattedOffer memory bestOffer);\n\n    // -- BRIDGE CONFIG VIEWS --\n\n    function getAllBridgeTokensEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, address[] memory tokensGlobal);\n\n    function getAllBridgeTokensNonEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, string[] memory tokensGlobal);\n\n    function getTokenAddressEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (address tokenGlobal, bool isEnabled);\n\n    function getTokenAddressNonEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (string memory tokenGlobal, bool isEnabled);\n}\n"
    },
    "contracts/router/BridgeQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Quoter} from \"./Quoter.sol\";\n\nimport {IBridgeRouter} from \"./interfaces/IBridgeRouter.sol\";\nimport {IBridgeQuoter} from \"./interfaces/IBridgeQuoter.sol\";\nimport {IBridge} from \"../vault/interfaces/IBridge.sol\";\nimport {IBridgeConfig} from \"../vault/interfaces/IBridgeConfig.sol\";\n\nimport {Offers} from \"./libraries/LibOffers.sol\";\n\ncontract BridgeQuoter is Quoter, IBridgeQuoter {\n    IBridgeConfig public immutable bridgeConfig;\n\n    /// @dev Setup flow:\n    /// 1. Create BridgeRouter contract\n    /// 2. Create BridgeQuoter contract\n    /// 3. Give BridgeQuoter ADAPTERS_STORAGE_ROLE in BridgeRouter contract\n    /// 4. Add tokens and adapters\n\n    /// PS. If the migration from one BridgeQuoter to another is needed (w/0 changing BridgeRouter):\n    /// 1. call oldBridgeQuoter.setAdapters([]), this will clear the adapters in BridgeRouter\n    /// 2. revoke ADAPTERS_STORAGE_ROLE from oldBridgeQuoter\n    /// 3. Do (2-4) from setup flow as usual\n    constructor(address payable _router, uint8 _maxSwaps)\n        Quoter(_router, _maxSwaps)\n    {\n        bridgeConfig = IBridge(IBridgeRouter(_router).bridge()).bridgeConfig();\n    }\n\n    // -- BEST PATH: initial chain --\n\n    function bestPathToBridge(\n        address tokenIn,\n        uint256 amountIn,\n        address bridgeTokenLocal\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        bestOffer = _findBestPathInitial(tokenIn, amountIn, bridgeTokenLocal);\n    }\n\n    function bestPathToBridgeEVM(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 chainId,\n        address bridgeTokenGlobal\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        address bridgeTokenLocal = bridgeConfig.findTokenEVM(\n            chainId,\n            bridgeTokenGlobal\n        );\n        if (bridgeTokenLocal != address(0)) {\n            bestOffer = _findBestPathInitial(\n                tokenIn,\n                amountIn,\n                bridgeTokenLocal\n            );\n        }\n    }\n\n    function bestPathToBridgeNonEVM(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 chainId,\n        string calldata bridgeTokenGlobal\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        address bridgeTokenLocal = bridgeConfig.findTokenNonEVM(\n            chainId,\n            bridgeTokenGlobal\n        );\n        if (bridgeTokenLocal != address(0)) {\n            bestOffer = _findBestPathInitial(\n                tokenIn,\n                amountIn,\n                bridgeTokenLocal\n            );\n        }\n    }\n\n    function _findBestPathInitial(\n        address tokenIn,\n        uint256 amountIn,\n        address bridgeTokenLocal\n    ) internal view returns (Offers.FormattedOffer memory bestOffer) {\n        if (bridgeConfig.isTokenEnabled(bridgeTokenLocal)) {\n            bestOffer = findBestPath(\n                tokenIn,\n                amountIn,\n                bridgeTokenLocal,\n                MAX_SWAPS\n            );\n        }\n    }\n\n    // -- BEST PATH: destination chain --\n\n    function bestPathFromBridge(\n        address bridgeTokenLocal,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        bestOffer = _findBestPathDestination(\n            bridgeTokenLocal,\n            amountIn,\n            tokenOut,\n            gasdropRequested\n        );\n    }\n\n    function bestPathFromBridgeEVM(\n        uint256 chainId,\n        address bridgeTokenGlobal,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        address bridgeTokenLocal = bridgeConfig.findTokenEVM(\n            chainId,\n            bridgeTokenGlobal\n        );\n        bestOffer = _findBestPathDestination(\n            bridgeTokenLocal,\n            amountIn,\n            tokenOut,\n            gasdropRequested\n        );\n    }\n\n    function bestPathFromBridgeNonEVM(\n        uint256 chainId,\n        string calldata bridgeTokenGlobal,\n        uint256 amountIn\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        address bridgeToken = bridgeConfig.findTokenNonEVM(\n            chainId,\n            bridgeTokenGlobal\n        );\n        // Default setting for bridging from non-EVM is no swap, GasDrop enabled\n        bestOffer = _findBestPathDestination(\n            bridgeToken,\n            amountIn,\n            bridgeToken,\n            true\n        );\n    }\n\n    function bestPathFromBridgeNonEVM(\n        uint256 chainId,\n        string calldata bridgeTokenGlobal,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) external view returns (Offers.FormattedOffer memory bestOffer) {\n        address bridgeToken = bridgeConfig.findTokenNonEVM(\n            chainId,\n            bridgeTokenGlobal\n        );\n\n        bestOffer = _findBestPathDestination(\n            bridgeToken,\n            amountIn,\n            tokenOut,\n            gasdropRequested\n        );\n    }\n\n    function _findBestPathDestination(\n        address bridgeTokenLocal,\n        uint256 amountIn,\n        address tokenOut,\n        bool gasdropRequested\n    ) internal view returns (Offers.FormattedOffer memory bestOffer) {\n        bool swapRequested = bridgeTokenLocal != tokenOut;\n        uint8 amountOfSwaps = IBridgeRouter(router).bridgeMaxSwaps();\n        (uint256 fee, , bool isEnabled, ) = bridgeConfig.calculateBridgeFee(\n            bridgeTokenLocal,\n            amountIn,\n            gasdropRequested,\n            swapRequested ? amountOfSwaps : 0\n        );\n\n        if (isEnabled && amountIn > fee) {\n            amountIn = amountIn - fee;\n\n            if (swapRequested) {\n                // Node group pays for gas, so:\n                // use maximum swaps permitted for bridge+swap transaction\n                bestOffer = findBestPath(\n                    bridgeTokenLocal,\n                    amountIn,\n                    tokenOut,\n                    amountOfSwaps\n                );\n            } else {\n                bestOffer.path = new address[](1);\n                bestOffer.path[0] = bridgeTokenLocal;\n\n                bestOffer.amounts = new uint256[](1);\n                bestOffer.amounts[0] = amountIn;\n\n                // bestOffer.adapters is empty\n            }\n        }\n    }\n\n    /// @dev Mirror functions from BridgeConfig, so that UI can only interact with BridgeQuoter\n\n    function getAllBridgeTokensEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, address[] memory tokensGlobal)\n    {\n        return bridgeConfig.getAllBridgeTokensEVM(chainTo);\n    }\n\n    function getAllBridgeTokensNonEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, string[] memory tokensGlobal)\n    {\n        return bridgeConfig.getAllBridgeTokensNonEVM(chainTo);\n    }\n\n    function getTokenAddressEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (address tokenGlobal, bool isEnabled)\n    {\n        return bridgeConfig.getTokenAddressEVM(tokenLocal, chainId);\n    }\n\n    function getTokenAddressNonEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (string memory tokenGlobal, bool isEnabled)\n    {\n        return bridgeConfig.getTokenAddressNonEVM(tokenLocal, chainId);\n    }\n}\n"
    },
    "contracts/vault/BridgeConfigV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport {IBridgeConfig} from \"./interfaces/IBridgeConfig.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable-solc8/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable-solc8/access/AccessControlUpgradeable.sol\";\n\ncontract BridgeConfig is\n    Initializable,\n    AccessControlUpgradeable,\n    IBridgeConfig\n{\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant NODEGROUP_ROLE = keccak256(\"NODEGROUP_ROLE\");\n\n    /// @dev List of tokenLocal\n    address[] public bridgeTokens;\n\n    /// @dev [tokenLocal => config]\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    /// @dev [tokenLocal => [chainID => tokenGlobal]]\n    mapping(address => mapping(uint256 => address)) internal localMapEVM;\n\n    /// @dev [chainID => [tokenGlobal => tokenLocal]]\n    mapping(uint256 => mapping(address => address)) internal globalMapEVM;\n\n    /// @dev [chainID => [tokenGlobal => tokenLocal]]\n    mapping(uint256 => mapping(string => address)) internal globalMapNonEVM;\n\n    uint256 internal constant FEE_DENOMINATOR = 10**10;\n    uint256 internal constant UINT_MAX = type(uint256).max;\n\n    function initialize() external initializer {\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // -- VIEWS --\n\n    /**\n     * @notice Calculates Synapse: Bridge fee for a token.\n     * @param token Bridged token.\n     * @param amount Amount of bridged tokens, in `token` decimals.\n     * @param gasdropRequested Whether user requested a gas airdrop (in that case minimum fee is higher).\n     * @param amountOfSwaps Amount of swaps after bridging (minimum fee is higher when amount is higher).\n     * @return fee Total Synapse: Bridge fee, in `token` decimals.\n     * @return bridgeToken Contract used for bridging `token` on this chain.\n     * @return isEnabled Whether bridging of `token` is enabled on this chain.\n     * @return isMintBurn Whether `token` is bridged on this chain by mint/burn or withdraw/deposit.\n     */\n    function calculateBridgeFee(\n        address token,\n        uint256 amount,\n        bool gasdropRequested,\n        uint256 amountOfSwaps\n    )\n        external\n        view\n        returns (\n            uint256 fee,\n            address bridgeToken,\n            bool isEnabled,\n            bool isMintBurn\n        )\n    {\n        TokenConfig memory config = tokenConfigs[token];\n        if (config.tokenType != TokenType.UNKNOWN && config.isEnabled) {\n            uint256 minFee = config.minBridgeFee +\n                (gasdropRequested ? config.minGasDropFee : 0) +\n                (amountOfSwaps > 0 ? config.minSwapFee : 0);\n\n            fee = (amount * config.synapseFee) / FEE_DENOMINATOR;\n\n            if (minFee > fee) {\n                fee = minFee;\n            } else if (fee > config.maxTotalFee) {\n                fee = config.maxTotalFee;\n            }\n\n            bridgeToken = config.bridgeToken;\n            isEnabled = true;\n            isMintBurn = config.tokenType == TokenType.MINT_BURN;\n        }\n    }\n\n    /**\n     * @notice Get bridge token information.\n     * @dev Most of the time, `token == bridgeToken`. Another contract is used when token.mint(to, amount)\n     * or token.burn(amount) are impossible to call.\n     * In that case, `bridgeToken` should implement such functions to perform mint/burn of `token`.\n     * The concept of `bridgeToken` is isolated in `Bridge` entirely.\n     * No one outside of `Bridge` needs to know how exactly `token` is being bridged.\n     * @param token Bridged token.\n     * @return bridgeToken Contract used for bridging `token` on this chain.\n     * @return isEnabled Whether bridging of `token` is enabled on this chain.\n     * @return isMintBurn Whether `token` is bridged on this chain by mint/burn or deposit/withdraw.\n     */\n    function getBridgeToken(address token)\n        external\n        view\n        returns (\n            address bridgeToken,\n            bool isEnabled,\n            bool isMintBurn\n        )\n    {\n        TokenConfig memory config = tokenConfigs[token];\n        bridgeToken = config.bridgeToken;\n        isEnabled = config.isEnabled;\n        isMintBurn = config.tokenType == TokenType.MINT_BURN;\n    }\n\n    /**\n     * @notice Get information about token address on another EVM chain.\n     * @param tokenLocal Bridged token address on this chain.\n     * @param chainId Id of EVM chain to get information about.\n     * @return tokenGlobal Token address on requested chain.\n     * @return isEnabled Whether bridging of `token` is enabled on this chain.\n     */\n    function getTokenAddressEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (address tokenGlobal, bool isEnabled)\n    {\n        tokenGlobal = localMapEVM[tokenLocal][chainId];\n        isEnabled = tokenConfigs[tokenLocal].isEnabled;\n    }\n\n    /**\n     * @notice Get information about token address on non-EVM chain.\n     * @param tokenLocal Bridged token address on this chain.\n     * @param chainId Id of non-EVM chain to get information about.\n     * @return tokenGlobal Token address on requested chain.\n     * @return isEnabled Whether bridging of `token` is enabled on this chain.\n     */\n    function getTokenAddressNonEVM(address tokenLocal, uint256 chainId)\n        external\n        view\n        returns (string memory tokenGlobal, bool isEnabled)\n    {\n        TokenConfig memory config = tokenConfigs[tokenLocal];\n        if (config.chainIdNonEVM == chainId) {\n            tokenGlobal = tokenConfigs[tokenLocal].bridgeTokenNonEVM;\n            isEnabled = tokenConfigs[tokenLocal].isEnabled;\n        }\n    }\n\n    /**\n     * @notice Find address of given token from EVM chain on this chain.\n     * @param chainId Id of EVM chain.\n     * @param tokenGlobal Token address on EVM chain.\n     * @return tokenLocal Bridge token address on this chain.\n     */\n    function findTokenEVM(uint256 chainId, address tokenGlobal)\n        external\n        view\n        returns (address tokenLocal)\n    {\n        tokenLocal = globalMapEVM[chainId][tokenGlobal];\n    }\n\n    /**\n     * @notice Find address of given token from non-EVM chain on this chain.\n     * @param chainId Id of non-EVM chain.\n     * @param tokenGlobal Token address on non-EVM chain.\n     * @return tokenLocal Bridge token address on this chain.\n     */\n    function findTokenNonEVM(uint256 chainId, string calldata tokenGlobal)\n        external\n        view\n        returns (address tokenLocal)\n    {\n        tokenLocal = globalMapNonEVM[chainId][tokenGlobal];\n    }\n\n    /**\n     * @notice Get a list of tokens bridgeable between current and a given EVM chain.\n     * @param chainTo EVM chain to bridge to.\n     * @return tokensLocal Bridge token addresses on this chain.\n     * @return tokensGlobal Bridge token addresses on `chainTo`.\n     */\n    function getAllBridgeTokensEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, address[] memory tokensGlobal)\n    {\n        uint256 amountTo = 0;\n\n        uint256 amountFull = bridgeTokens.length;\n        for (uint256 i = 0; i < amountFull; ++i) {\n            if (localMapEVM[bridgeTokens[i]][chainTo] != address(0)) {\n                ++amountTo;\n            }\n        }\n\n        tokensLocal = new address[](amountTo);\n        tokensGlobal = new address[](amountTo);\n        amountTo = 0;\n\n        for (uint256 i = 0; i < amountFull; ++i) {\n            address tokenLocal = bridgeTokens[i];\n            address tokenGlobal = localMapEVM[tokenLocal][chainTo];\n            if (tokenGlobal != address(0)) {\n                tokensLocal[amountTo] = tokenLocal;\n                tokensGlobal[amountTo] = tokenGlobal;\n                ++amountTo;\n            }\n        }\n    }\n\n    /**\n     * @notice Get a list of tokens bridgeable between current and a given non-EVM chain.\n     * @param chainTo Non-EVM chain to bridge to.\n     * @return tokensLocal Bridge token addresses on this chain.\n     * @return tokensGlobal Bridge token addresses on `chainTo`.\n     */\n    function getAllBridgeTokensNonEVM(uint256 chainTo)\n        external\n        view\n        returns (address[] memory tokensLocal, string[] memory tokensGlobal)\n    {\n        uint256 amountTo = 0;\n\n        uint256 amountFull = bridgeTokens.length;\n        for (uint256 i = 0; i < amountFull; ++i) {\n            if (tokenConfigs[bridgeTokens[i]].chainIdNonEVM == chainTo) {\n                ++amountTo;\n            }\n        }\n\n        tokensLocal = new address[](amountTo);\n        tokensGlobal = new string[](amountTo);\n        amountTo = 0;\n\n        for (uint256 i = 0; i < amountFull; ++i) {\n            address tokenLocal = bridgeTokens[i];\n            TokenConfig memory config = tokenConfigs[tokenLocal];\n            if (config.chainIdNonEVM == chainTo) {\n                tokensLocal[amountTo] = tokenLocal;\n                tokensGlobal[amountTo] = config.bridgeTokenNonEVM;\n                ++amountTo;\n            }\n        }\n    }\n\n    /**\n     * @notice Check is bridging for given token is currently enabled.\n     * @param bridgeToken Token in question.\n     */\n    function isTokenEnabled(address bridgeToken) external view returns (bool) {\n        return tokenConfigs[bridgeToken].isEnabled;\n    }\n\n    // -- BRIDGE CONFIG: swap fees --\n\n    /**\n     * @notice Add a new Bridge token config. Called by Governance only.\n     * @dev This will revert if a token has been added before, use {updateTokenFees},\n     * {updateTokenSetup} to update things later.\n     * @param token Token to add: the version that is used on this chain.\n     * @param bridgeToken Bridge token that will be used for bridging `token`.\n     * @param isMintBurn Specifies if token is bridged via mint-burn or deposit-withdraw.\n     * @param synapseFee Synapse:Bridge fee value(i.e. 0.1%), multiplied by `FEE_DENOMINATOR`.\n     * @param maxTotalFee Maximum total bridge fee, in `token` decimals.\n     * @param minBridgeFee Minimum fee covering bridging in (always present), in `token` decimals.\n     * @param minGasDropFee Minimum fee covering covering GasDrop (when GasDrop is present), in `token` decimals.\n     * @param minSwapFee Minimum fee covering covering further swap (when swap is present), in `token` decimals.\n     */\n    function addNewToken(\n        address token,\n        address bridgeToken,\n        bool isMintBurn,\n        uint256 synapseFee,\n        uint256 maxTotalFee,\n        uint256 minBridgeFee,\n        uint256 minGasDropFee,\n        uint256 minSwapFee\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        TokenConfig storage config = tokenConfigs[token];\n        require(\n            config.tokenType == TokenType.UNKNOWN,\n            \"Token is already added\"\n        );\n        bridgeTokens.push(token);\n\n        _updateTokenSetup(token, bridgeToken, isMintBurn);\n        updateTokenFees(\n            token,\n            synapseFee,\n            maxTotalFee,\n            minBridgeFee,\n            minGasDropFee,\n            minSwapFee\n        );\n    }\n\n    /**\n     * @notice Update an existing `token` setup. Called by Governance only.\n     * @dev This will revert if `token` wasn't added before.\n     * @param token Token to add: the version that is used on this chain\n     * @param bridgeToken Bridge token that will be used for bridging `token`\n     * @param isMintBurn Specifies if token is bridged via mint-burn or deposit-withdraw\n     */\n    function updateTokenSetup(\n        address token,\n        address bridgeToken,\n        bool isMintBurn\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        TokenConfig storage config = tokenConfigs[token];\n        require(config.tokenType != TokenType.UNKNOWN, \"Token is not added\");\n\n        _updateTokenSetup(token, bridgeToken, isMintBurn);\n    }\n\n    function _updateTokenSetup(\n        address token,\n        address bridgeToken,\n        bool isMintBurn\n    ) internal {\n        TokenConfig storage config = tokenConfigs[token];\n\n        config.bridgeToken = bridgeToken;\n        config.tokenType = isMintBurn\n            ? TokenType.MINT_BURN\n            : TokenType.DEPOSIT_WITHDRAW;\n\n        emit TokenSetupUpdated(token, bridgeToken, isMintBurn);\n    }\n\n    /**\n     * @notice Update an existing `token` fees. Called by Governance only.\n     * @param token Token to add: the version that is used on this chain.\n     * @param synapseFee Synapse:Bridge fee value(i.e. 0.1%), multiplied by `FEE_DENOMINATOR`.\n     * @param maxTotalFee Maximum total bridge fee, in `token` decimals.\n     * @param minBridgeFee Minimum fee covering bridging in (always present), in `token` decimals.\n     * @param minGasDropFee Minimum fee covering covering GasDrop (when GasDrop is present), in `token` decimals.\n     * @param minSwapFee Minimum fee covering covering further swap (when swap is present), in `token` decimals.\n     */\n    function updateTokenFees(\n        address token,\n        uint256 synapseFee,\n        uint256 maxTotalFee,\n        uint256 minBridgeFee,\n        uint256 minGasDropFee,\n        uint256 minSwapFee\n    ) public onlyRole(GOVERNANCE_ROLE) {\n        TokenConfig storage config = tokenConfigs[token];\n        require(config.tokenType != TokenType.UNKNOWN, \"Token is not added\");\n\n        config.synapseFee = synapseFee;\n        config.maxTotalFee = maxTotalFee;\n        config.minBridgeFee = minBridgeFee;\n        config.minGasDropFee = minGasDropFee;\n        config.minSwapFee = minSwapFee;\n\n        emit TokenFeesUpdated(\n            token,\n            synapseFee,\n            maxTotalFee,\n            minBridgeFee,\n            minGasDropFee,\n            minSwapFee\n        );\n    }\n\n    // -- BRIDGE CONFIG: Token Map (Governance) --\n\n    /**\n     * @dev Checks whether provided arrays length match,\n     * also checks for blank values.\n     */\n    modifier checkConfigEVM(\n        uint256[] calldata chainIdsEVM,\n        address[] calldata bridgeTokensEVM\n    ) {\n        require(bridgeTokensEVM.length == chainIdsEVM.length, \"!length\");\n        for (uint256 i = 0; i < chainIdsEVM.length; ++i) {\n            require(chainIdsEVM[i] != 0, \"!ID\");\n            require(bridgeTokensEVM[i] != address(0), \"!token\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Adds a new token Map. Called by Governance only.\n     * @dev This will emit TokenMapUpdated Event, which Validators are supposed to relay\n     * to other chains.\n     * This will revert if:\n     * 1. Current chain ID is not present in the list.\n     * 2. Token wasn't added via {addNewBridgeToken}.\n     * 3. Map was already added, use {addChainsToMap} to update it later.\n     * @param chainIdsEVM IDs of all EVM chains token is deployed on, INCLUDING current one.\n     * @param bridgeTokensEVM Token addresses on all EVM chains token is deployed on, INCLUDING current one.\n     * @param chainIdNonEVM ID of non-EVM chain, token is deployed on. Zero, if not deployed.\n     * @param bridgeTokenNonEVM Address of token on non-EVM chain. Ignored, if `chainIdNonEVM==0`.\n     */\n    function addNewMap(\n        uint256[] calldata chainIdsEVM,\n        address[] calldata bridgeTokensEVM,\n        uint256 chainIdNonEVM,\n        string calldata bridgeTokenNonEVM\n    )\n        external\n        onlyRole(GOVERNANCE_ROLE)\n        checkConfigEVM(chainIdsEVM, bridgeTokensEVM)\n    {\n        _updateMap(\n            chainIdsEVM,\n            bridgeTokensEVM,\n            chainIdNonEVM,\n            bridgeTokenNonEVM,\n            true\n        );\n\n        // We were given the full token map, will emit it, so that\n        // Bridge.addToMap() can be called by the Node Group on other chains\n        emit TokenMapUpdated(\n            chainIdsEVM,\n            bridgeTokensEVM,\n            chainIdNonEVM,\n            bridgeTokenNonEVM\n        );\n    }\n\n    /**\n     * @notice Adds chains to an existing token Map. Called by Governance only.\n     * @dev This will emit `TokenMapUpdated` Event, which Validators are supposed to relay\n     * to other chains, both old and new ones.\n     * This will revert if:\n     * 1. Token wasn't added via {addNewBridgeToken}.\n     * 2. Map wasn't added via {addNewMap} or {updateMap}.\n     * @param token Token to update: the version that is used on this chain.\n     * @param newChainIdsEVM IDs of NEW EVM chains token is deployed on. This excludes any old chains.\n     * @param newBridgeTokensEVM Token addresses on NEW EVM chains token is deployed on. This excludes any old chains.\n     * @param chainIdNonEVM ID of NEW non-EVM chain, token is deployed on. Ignored, if zero.\n     * @param bridgeTokenNonEVM Address of token on NEW non-EVM chain. Ignored, if `chainIdNonEVM==0`.\n     */\n    function addChainsToMap(\n        address token,\n        uint256[] calldata newChainIdsEVM,\n        address[] calldata newBridgeTokensEVM,\n        uint256 chainIdNonEVM,\n        string calldata bridgeTokenNonEVM\n    )\n        external\n        onlyRole(GOVERNANCE_ROLE)\n        checkConfigEVM(newChainIdsEVM, newBridgeTokensEVM)\n    {\n        TokenConfig memory config = tokenConfigs[token];\n        require(config.chainIdsEVM.length != 0, \"!Map\");\n\n        _updateTokenMap(\n            token,\n            newChainIdsEVM,\n            newBridgeTokensEVM,\n            chainIdNonEVM,\n            bridgeTokenNonEVM\n        );\n\n        // config.chainIdsEVM now contains both old and new chainIds\n        address[] memory allTokenAddresses = _getAllTokenAddressesEVM(\n            token,\n            config.chainIdsEVM\n        );\n\n        // Use both old and new chains in the emitted Event\n        emit TokenMapUpdated(\n            config.chainIdsEVM,\n            allTokenAddresses,\n            chainIdNonEVM,\n            bridgeTokenNonEVM\n        );\n    }\n\n    /**\n     * @notice Enable/Disable token bridging. Called by Governance only.\n     * @dev This will emit `TokenStatusUpdated`, which Validators are supposed to relay\n     * to other chains. Wil not emit anything, if token status hasn't changed.\n     * This will revert if:\n     * 1. Token wasn't added via {addNewBridgeToken}.\n     * 2. Map wasn't added via {addNewMap} or {updateMap}.\n     * @param token Token to toggle: the version that is used on this chain.\n     * @param isEnabled New token Bridge status.\n     */\n    function changeTokenStatus(address token, bool isEnabled)\n        external\n        onlyRole(GOVERNANCE_ROLE)\n    {\n        if (_changeTokenStatus(token, isEnabled)) {\n            TokenConfig memory config = tokenConfigs[address(token)];\n\n            address[] memory allTokenAddresses = _getAllTokenAddressesEVM(\n                address(token),\n                config.chainIdsEVM\n            );\n\n            emit TokenStatusUpdated(\n                config.chainIdsEVM,\n                allTokenAddresses,\n                isEnabled\n            );\n        }\n    }\n\n    /**\n     * @notice Delete this chain's version of token from Bridge on all chains.\n     * Other chains' version of token will remain. Called by Governance only.\n     * @dev This will emit `TokenDeleted`, which validators are supposed to relay\n     * to other chains. This will revert if\n     * 1. Token wasn't added via {addNewBridgeToken}.\n     * @param token Token to delete: the version that is used on this chain.\n     */\n    function deleteTokenEVM(address token) external onlyRole(GOVERNANCE_ROLE) {\n        _deleteTokenEVM(address(token));\n\n        emit TokenDeleted(block.chainid, address(token));\n    }\n\n    /**\n     * @notice Delete given chain's version of token from Bridge on all chains.\n     * Other chains' version of token will remain. Called by Governance only.\n     * @param chainId Id of chain where token (being deleted) is deployed.\n     * @param tokenGlobal Token to delete: the given that is used on given chain.\n     */\n    function removeGlobalTokenEVM(uint256 chainId, address tokenGlobal)\n        external\n        onlyRole(GOVERNANCE_ROLE)\n    {\n        _removeGlobalTokenEVM(chainId, tokenGlobal);\n\n        emit TokenDeleted(chainId, tokenGlobal);\n    }\n\n    // -- BRIDGE CONFIG: Token Map (Node Group) --\n\n    /**\n     * @notice Adds chains to an existing token Map. Called by Node Group only.\n     * @dev This will NOT overwrite data for chains already existing in Map.\n     * This will revert if:\n     * 1. Current chain ID is not present in the list.\n     * 2. Token wasn't added via {addNewBridgeToken}.\n     * @param chainIdsEVM IDs of all EVM chains token is deployed on, INCLUDING current one.\n     * @param bridgeTokensEVM Token addresses on all EVM chains token is deployed on, INCLUDING current one.\n     * @param chainIdNonEVM ID of non-EVM chain, token is deployed on. Zero, if not deployed.\n     * @param bridgeTokenNonEVM Address of token on non-EVM chain. Ignored, if `chainIdNonEVM==0`.\n     */\n    function updateMap(\n        uint256[] calldata chainIdsEVM,\n        address[] calldata bridgeTokensEVM,\n        uint256 chainIdNonEVM,\n        string calldata bridgeTokenNonEVM\n    )\n        external\n        onlyRole(NODEGROUP_ROLE)\n        checkConfigEVM(chainIdsEVM, bridgeTokensEVM)\n    {\n        _updateMap(\n            chainIdsEVM,\n            bridgeTokensEVM,\n            chainIdNonEVM,\n            bridgeTokenNonEVM,\n            false\n        );\n\n        // DO NOT emit anything, as this is a relayed setup tx\n    }\n\n    /**\n     * @notice Enable/Disable token bridging. Called by Node Group only.\n     * @dev This will revert if:\n     * 1. Token wasn't added via {addNewBridgeToken}.\n     * 2. Map wasn't added via {addNewMap} or {updateMap}.\n     * @param token Token to toggle: the version that is used on this chain.\n     * @param isEnabled New token Bridge status.\n     */\n    function updateTokenStatus(address token, bool isEnabled)\n        external\n        onlyRole(NODEGROUP_ROLE)\n    {\n        _changeTokenStatus(token, isEnabled);\n\n        // DO NOT emit anything, as this is a relayed setup tx\n    }\n\n    function removeTokenEVM(uint256 chainId, address tokenAddress)\n        external\n        onlyRole(NODEGROUP_ROLE)\n    {\n        // Check if current chain is the specified one for deleting\n        if (chainId == block.chainid) {\n            // delete token entirely on this chain\n            _deleteTokenEVM(tokenAddress);\n        } else {\n            // remove records about token on given chain\n            _removeGlobalTokenEVM(chainId, tokenAddress);\n        }\n\n        // DO NOT emit anything, as this is a relayed deletion tx\n    }\n\n    function _getAllTokenAddressesEVM(address token, uint256[] memory chainIds)\n        internal\n        view\n        returns (address[] memory allTokenAddresses)\n    {\n        uint256 amount = chainIds.length;\n        allTokenAddresses = new address[](amount);\n\n        for (uint256 i = 0; i < amount; i++) {\n            allTokenAddresses[i] = localMapEVM[token][chainIds[i]];\n        }\n    }\n\n    // -- BRIDGE CONFIG: token setup (internal implementation) --\n\n    function _changeTokenStatus(address token, bool isEnabled)\n        internal\n        returns (bool)\n    {\n        TokenConfig storage config = tokenConfigs[token];\n        require(config.bridgeToken != address(0), \"!token\");\n        require(config.chainIdsEVM.length != 0, \"!Map\");\n\n        if (config.isEnabled == isEnabled) {\n            // Y U DO DIS\n            return false;\n        }\n\n        config.isEnabled = isEnabled;\n        return true;\n    }\n\n    function _findLocalToken(\n        uint256[] calldata chainIdsEVM,\n        address[] calldata bridgeTokensEVM\n    ) internal view returns (address token) {\n        // Find bridge token address on this chain\n        for (uint256 i = 0; i < chainIdsEVM.length; i++) {\n            if (chainIdsEVM[i] == block.chainid) {\n                token = bridgeTokensEVM[i];\n                break;\n            }\n        }\n        require(token != address(0), \"!Found\");\n    }\n\n    function _updateMap(\n        uint256[] calldata chainIdsEVM,\n        address[] calldata bridgeTokensEVM,\n        uint256 chainIdNonEVM,\n        string calldata bridgeTokenNonEVM,\n        bool checkEmpty\n    ) internal {\n        address tokenLocal = _findLocalToken(chainIdsEVM, bridgeTokensEVM);\n        require(\n            !checkEmpty || tokenConfigs[tokenLocal].chainIdsEVM.length == 0,\n            \"+Map\"\n        );\n        _updateTokenMap(\n            tokenLocal,\n            chainIdsEVM,\n            bridgeTokensEVM,\n            chainIdNonEVM,\n            bridgeTokenNonEVM\n        );\n    }\n\n    function _updateTokenMap(\n        address tokenLocal,\n        uint256[] calldata chainIdsEVM,\n        address[] calldata bridgeTokensEVM,\n        uint256 chainIdNonEVM,\n        string calldata bridgeTokenNonEVM\n    ) internal {\n        TokenConfig storage config = tokenConfigs[tokenLocal];\n\n        require(config.bridgeToken != address(0), \"!token\");\n\n        for (uint256 i = 0; i < chainIdsEVM.length; i++) {\n            uint256 chainId = chainIdsEVM[i];\n            // Add chain to the map, only if it is currently missing\n            if (localMapEVM[tokenLocal][chainId] == address(0)) {\n                address tokenGlobal = bridgeTokensEVM[i];\n                localMapEVM[tokenLocal][chainId] = tokenGlobal;\n                globalMapEVM[chainId][tokenGlobal] = tokenLocal;\n                config.chainIdsEVM.push(chainId);\n            }\n        }\n\n        if (chainIdNonEVM != 0) {\n            require(config.chainIdNonEVM == 0, \"+chain\");\n            globalMapNonEVM[chainIdNonEVM][bridgeTokenNonEVM] = tokenLocal;\n            config.chainIdNonEVM = chainIdNonEVM;\n            config.bridgeTokenNonEVM = bridgeTokenNonEVM;\n        }\n    }\n\n    function _deleteTokenEVM(address tokenLocal) internal {\n        TokenConfig storage config = tokenConfigs[tokenLocal];\n        require(config.bridgeToken != address(0), \"!token\");\n\n        {\n            uint256 index = UINT_MAX;\n            uint256 tokensAmount = bridgeTokens.length;\n            for (uint256 i = 0; i < tokensAmount; ++i) {\n                if (bridgeTokens[i] == tokenLocal) {\n                    index = i;\n                    break;\n                }\n            }\n\n            require(index != UINT_MAX, \"!found\");\n\n            // Replace found token with the last one\n            bridgeTokens[index] = bridgeTokens[tokensAmount - 1];\n            // Remove now duplicated last token from list\n            bridgeTokens.pop();\n        }\n\n        uint256 chainAmount = config.chainIdsEVM.length;\n        for (uint256 i = 0; i < chainAmount; ++i) {\n            uint256 chainId = config.chainIdsEVM[i];\n            address tokenGlobal = localMapEVM[tokenLocal][chainId];\n\n            localMapEVM[tokenLocal][chainId] = address(0);\n            globalMapEVM[chainId][tokenGlobal] = address(0);\n        }\n\n        // Zero out the token config\n        delete tokenConfigs[tokenLocal];\n    }\n\n    function _removeGlobalTokenEVM(uint256 chainId, address tokenGlobal)\n        internal\n    {\n        address tokenLocal = globalMapEVM[chainId][tokenGlobal];\n        require(tokenLocal != address(0), \"!token\");\n\n        {\n            TokenConfig storage config = tokenConfigs[tokenLocal];\n            uint256 index = UINT_MAX;\n            uint256 chainsAmount = config.chainIdsEVM.length;\n            for (uint256 i = 0; i < chainsAmount; ++i) {\n                if (config.chainIdsEVM[i] == chainId) {\n                    index = i;\n                    break;\n                }\n            }\n\n            require(index != UINT_MAX, \"!found\");\n\n            // Replace found chain with the last one\n            config.chainIdsEVM[index] = config.chainIdsEVM[chainsAmount - 1];\n            // Remove last chain from list, which is now duplicated\n            config.chainIdsEVM.pop();\n        }\n\n        localMapEVM[tokenLocal][chainId] = address(0);\n        globalMapEVM[chainId][tokenGlobal] = address(0);\n    }\n}\n"
    },
    "contracts/router/helper/test/TestSolidlyAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAdapter} from \"../../interfaces/IAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport {ISolidlyPair} from \"../../adapters/interfaces/ISolidlyPair.sol\";\n\nimport \"hardhat/console.sol\";\n\n// solhint-disable reason-string\n\ninterface ISolidlyRouter {\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    function getAmountsOut(uint256 amountIn, Route[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ncontract TestSolidlyAdapter {\n    using SafeERC20 for IERC20;\n\n    ISolidlyRouter private immutable router;\n    bool private immutable stable;\n\n    constructor(address _routerAddress, bool _stable) {\n        router = ISolidlyRouter(_routerAddress);\n        stable = _stable;\n    }\n\n    function testSwap(\n        address _adapterAddress,\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        bool _checkUnderQuoting,\n        uint256 _iteration\n    ) external {\n        IAdapter adapter = IAdapter(_adapterAddress);\n\n        address depositAddress = adapter.depositAddress(_tokenIn, _tokenOut);\n        if (depositAddress == address(0)) {\n            console.log(\"Swap # %s\", _iteration);\n            console.log(\"Swap not found for %s %s\", _tokenIn, _tokenOut);\n            revert(\"Swap not found\");\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = ISolidlyPair(depositAddress)\n            .getReserves();\n\n        IERC20(_tokenIn).safeTransferFrom(\n            msg.sender,\n            depositAddress,\n            _amountIn\n        );\n\n        uint256 amountQuoted = adapter.query(_amountIn, _tokenIn, _tokenOut);\n\n        checkAmountQuoted(\n            _amountIn,\n            _tokenIn,\n            _tokenOut,\n            amountQuoted,\n            _iteration\n        );\n\n        uint256 amountSwapped = 0;\n\n        try\n            adapter.swap(_amountIn, _tokenIn, _tokenOut, address(this))\n        returns (uint256 _amountSwapped) {\n            amountSwapped = _amountSwapped;\n        } catch {\n            console.log(\"Swap failed: # %s\", _iteration);\n            console.log(\"%s -> %s\", _tokenIn, _tokenOut);\n            console.log(\"AmountIn: %s\", _amountIn);\n            console.log(\"Quote: %s\", amountQuoted);\n            console.log(\"%s %s\", reserve0, reserve1);\n            revert(\"swap() failed\");\n        }\n        uint256 amountReceived = IERC20(_tokenOut).balanceOf(address(this));\n\n        if (amountSwapped != amountReceived) {\n            console.log(\"Swap # %s\", _iteration);\n            console.log(\n                \"swap: Expected %s, got %s\",\n                amountSwapped,\n                amountReceived\n            );\n            revert(\"swap() failed to return amount of tokens\");\n        }\n\n        if (\n            amountQuoted > amountReceived ||\n            (amountQuoted < amountReceived && _checkUnderQuoting)\n        ) {\n            console.log(\"Swap # %s\", _iteration);\n            if (amountQuoted > amountReceived) {\n                console.log(\n                    \"swap: (over)Quoted %s, got %s (diff: %s)\",\n                    amountQuoted,\n                    amountReceived,\n                    amountQuoted - amountReceived\n                );\n            } else {\n                console.log(\n                    \"swap: (under)Quoted %s, got %s (diff: %s)\",\n                    amountQuoted,\n                    amountReceived,\n                    amountReceived - amountQuoted\n                );\n            }\n            revert(\"query() failed to provide a good quote\");\n        }\n\n        // console.log(\"%s -> %s\", _tokenIn, _tokenOut);\n        // console.log(\"AmountIn: %s\", _amountIn);\n        // console.log(\"Quote: %s\", amountQuoted);\n        IERC20(_tokenOut).safeTransfer(msg.sender, amountReceived);\n    }\n\n    function checkAmountQuoted(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountQuoted,\n        uint256 _iteration\n    ) internal view {\n        ISolidlyRouter.Route[] memory path = new ISolidlyRouter.Route[](1);\n        path[0] = ISolidlyRouter.Route(_tokenIn, _tokenOut, stable);\n        uint256[] memory _amountsOut = router.getAmountsOut(_amountIn, path);\n        uint256 _amountOut = _amountsOut[1];\n        if (_amountOut != _amountQuoted) {\n            console.log(\"Swap # %s\", _iteration);\n            if (_amountQuoted > _amountOut) {\n                console.log(\n                    \"swap: (over)Quoted %s, actually %s (diff: %s)\",\n                    _amountQuoted,\n                    _amountOut,\n                    _amountQuoted - _amountOut\n                );\n            } else {\n                console.log(\n                    \"swap: (under)Quoted %s, actually %s (diff: %s)\",\n                    _amountQuoted,\n                    _amountOut,\n                    _amountOut - _amountQuoted\n                );\n            }\n            revert(\"query() failed to provide a good quote\");\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/ISolidlyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISolidlyPair {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function getAmountOut(uint256 amountIn, address tokenIn)\n        external\n        view\n        returns (uint256);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        );\n}\n"
    },
    "contracts/router/adapters/solidly/SolidlyAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISolidlyPair} from \"../interfaces/ISolidlyPair.sol\";\nimport {Adapter} from \"../../Adapter.sol\";\n\nimport {Address} from \"@openzeppelin/contracts-solc8/utils/Address.sol\";\n\n// solhint-disable reason-string\n\ncontract SolidlyAdapter is Adapter {\n    address public immutable solidlyFactory;\n    bool public immutable stable;\n\n    bytes32 internal immutable initCodeHash;\n\n    /**\n     * @dev Default Solidly fee is 0.1% = 10bp\n     */\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _solidlyFactoryAddress,\n        bytes32 _initCodeHash,\n        bool _stable\n    ) Adapter(_name, _swapGasEstimate) {\n        solidlyFactory = _solidlyFactoryAddress;\n        initCodeHash = _initCodeHash;\n        stable = _stable;\n    }\n\n    function _depositAddress(address _tokenIn, address _tokenOut)\n        internal\n        view\n        override\n        returns (address pair)\n    {\n        bytes32 salt = _tokenIn < _tokenOut\n            ? keccak256(abi.encodePacked(_tokenIn, _tokenOut, stable))\n            : keccak256(abi.encodePacked(_tokenOut, _tokenIn, stable));\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            solidlyFactory,\n                            salt,\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        address _pair = _depositAddress(_tokenIn, _tokenOut);\n\n        _amountOut = _getPairAmountOut(_pair, _tokenIn, _amountIn);\n        require(_amountOut > 0, \"Adapter: Insufficient output amount\");\n\n        if (_tokenIn < _tokenOut) {\n            ISolidlyPair(_pair).swap(0, _amountOut, _to, new bytes(0));\n        } else {\n            ISolidlyPair(_pair).swap(_amountOut, 0, _to, new bytes(0));\n        }\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        address _pair = _depositAddress(_tokenIn, _tokenOut);\n\n        _amountOut = _getPairAmountOut(_pair, _tokenIn, _amountIn);\n    }\n\n    function _getPairAmountOut(\n        address _pair,\n        address _tokenIn,\n        uint256 _amountIn\n    ) internal view returns (uint256 _amountOut) {\n        if (Address.isContract(_pair)) {\n            try ISolidlyPair(_pair).getAmountOut(_amountIn, _tokenIn) returns (\n                uint256 amountOut\n            ) {\n                _amountOut = amountOut;\n            } catch {\n                this;\n            }\n        }\n    }\n}\n"
    },
    "contracts/router/Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAdapter} from \"./interfaces/IAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {IWETH9} from \"@synapseprotocol/sol-lib/contracts/universal/interfaces/IWETH9.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts-4.4.2/access/Ownable.sol\";\n\n// solhint-disable reason-string\n\nabstract contract Adapter is Ownable, IAdapter {\n    using SafeERC20 for IERC20;\n\n    string public name;\n    uint256 public swapGasEstimate;\n\n    uint256 internal constant UINT_MAX = type(uint256).max;\n\n    constructor(string memory _name, uint256 _swapGasEstimate) {\n        name = _name;\n        setSwapGasEstimate(_swapGasEstimate);\n    }\n\n    /**\n     * @notice Fallback function\n     * @dev use recoverGAS() to recover GAS sent to this contract\n     */\n    receive() external payable {\n        // silence the linter\n        this;\n    }\n\n    /// @dev this is estimated amount of gas that's used by swap() implementation\n    function setSwapGasEstimate(uint256 _swapGasEstimate) public onlyOwner {\n        swapGasEstimate = _swapGasEstimate;\n        emit UpdatedGasEstimate(address(this), _swapGasEstimate);\n    }\n\n    // -- RESTRICTED ALLOWANCE FUNCTIONS --\n\n    function setInfiniteAllowance(IERC20 token, address spender)\n        external\n        onlyOwner\n    {\n        _setInfiniteAllowance(token, spender);\n    }\n\n    /**\n     * @notice Revoke token allowance\n     *\n     * @param token address\n     * @param spender address\n     */\n    function revokeTokenAllowance(IERC20 token, address spender)\n        external\n        onlyOwner\n    {\n        token.safeApprove(spender, 0);\n    }\n\n    // -- RESTRICTED RECOVER TOKEN FUNCTIONS --\n\n    /**\n     * @notice Recover ERC20 from contract\n     * @param token token to recover\n     */\n    function recoverERC20(IERC20 token) external onlyOwner {\n        uint256 amount = token.balanceOf(address(this));\n        require(amount > 0, \"Adapter: Nothing to recover\");\n\n        emit Recovered(address(token), amount);\n        token.safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Recover GAS from contract\n     */\n    function recoverGAS() external onlyOwner {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"Adapter: Nothing to recover\");\n\n        emit Recovered(address(0), amount);\n        //solhint-disable-next-line\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"GAS transfer failed\");\n    }\n\n    /**\n     * @return Address to transfer tokens in order for swap() to work\n     */\n\n    function depositAddress(address tokenIn, address tokenOut)\n        external\n        view\n        returns (address)\n    {\n        return _depositAddress(tokenIn, tokenOut);\n    }\n\n    /**\n     * @notice Get query for a swap through this adapter\n     *\n     * @param amountIn input amount in starting token\n     * @param tokenIn ERC20 token being sold\n     * @param tokenOut ERC20 token being bought\n     */\n    function query(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint256) {\n        if (\n            amountIn == 0 ||\n            tokenIn == tokenOut ||\n            !_checkTokens(tokenIn, tokenOut)\n        ) {\n            return 0;\n        }\n        return _query(amountIn, tokenIn, tokenOut);\n    }\n\n    /**\n     * @notice Execute a swap with given input amount of tokens from tokenIn to tokenOut,\n     *         assuming input tokens were transferred to depositAddress(tokenIn, tokenOut)\n     *\n     * @param amountIn input amount in starting token\n     * @param tokenIn ERC20 token being sold\n     * @param tokenOut ERC20 token being bought\n     * @param to address where swapped funds should be sent to\n     *\n     * @return amountOut amount of tokenOut tokens received in swap\n     */\n    function swap(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        address to\n    ) external returns (uint256 amountOut) {\n        require(amountIn != 0, \"Adapter: Insufficient input amount\");\n        require(to != address(0), \"Adapter: to cannot be zero address\");\n        require(tokenIn != tokenOut, \"Adapter: Tokens must differ\");\n        require(_checkTokens(tokenIn, tokenOut), \"Adapter: unknown tokens\");\n        _approveIfNeeded(tokenIn, amountIn);\n        amountOut = _swap(amountIn, tokenIn, tokenOut, to);\n    }\n\n    // -- INTERNAL FUNCTIONS\n\n    /**\n     * @notice Return expected funds to user\n     *\n     * @dev this will do nothing, if funds need to stay in this contract\n     *\n     * @param token address\n     * @param amount tokens to return\n     * @param to address where funds should be sent to\n     */\n    function _returnTo(\n        address token,\n        uint256 amount,\n        address to\n    ) internal {\n        if (address(this) != to) {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Check allowance, and update if it is not big enough\n     *\n     * @param token token to check\n     * @param amount minimum allowance that we need\n     * @param spender address that will be given allowance\n     */\n    function _checkAllowance(\n        IERC20 token,\n        uint256 amount,\n        address spender\n    ) internal {\n        uint256 _allowance = token.allowance(address(this), spender);\n        if (_allowance < amount) {\n            // safeApprove should only be called when setting an initial allowance,\n            // or when resetting it to zero. (c) openzeppelin\n            if (_allowance != 0) {\n                token.safeApprove(spender, 0);\n            }\n            token.safeApprove(spender, UINT_MAX);\n        }\n    }\n\n    function _setInfiniteAllowance(IERC20 token, address spender) internal {\n        _checkAllowance(token, UINT_MAX, spender);\n    }\n\n    // -- INTERNAL VIRTUAL FUNCTIONS\n\n    /**\n     * @notice Approves token for the underneath swapper to use\n     *\n     * @dev Implement via _checkAllowance(tokenIn, amount, POOL)\n     *      if actually needed\n     */\n    function _approveIfNeeded(address, uint256) internal virtual {\n        this;\n    }\n\n    /**\n     * @notice Checks if a swap between two tokens is supported by adapter\n     */\n    function _checkTokens(address, address)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Internal implementation for depositAddress\n     *\n     * @dev This aims to reduce the amount of extra token transfers:\n     *      some (1) of underneath swappers will have the ability to receive tokens and then swap,\n     *      while some (2) will only be able to pull tokens while swapping.\n     *      Use swapper address for (1) and Adapter address for (2)\n     */\n    function _depositAddress(address tokenIn, address tokenOut)\n        internal\n        view\n        virtual\n        returns (address);\n\n    /**\n     * @notice Internal implementation of a swap\n     *\n     * @dev 1. All variables are already checked\n     *      2. Use _returnTo(tokenOut, amountOut, to) to return tokens, only if\n     *         underneath swapper can't send swapped tokens to arbitrary address.\n     *      3. Wrapping is handled external to this function\n     *\n     * @param amountIn amount being sold\n     * @param tokenIn ERC20 token being sold\n     * @param tokenOut ERC20 token being bought\n     * @param to Where received tokens are sent to\n     *\n     * @return Amount of tokenOut tokens received in swap\n     */\n    function _swap(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        address to\n    ) internal virtual returns (uint256);\n\n    /**\n     * @notice Internal implementation of query\n     *\n     * @dev All variables are already checked.\n     *      This should ALWAYS return amountOut such as: the swapper underneath\n     *      is able to produce AT LEAST amountOut in exchange for EXACTLY amountIn\n     *      For efficiency reasons, returning the exact quote is preferable,\n     *      however, if the swapper doesn't have a reliable quoting method,\n     *      it's safe to underquote the swapped amount\n     *\n     * @param amountIn input amount in starting token\n     * @param tokenIn ERC20 token being sold\n     * @param tokenOut ERC20 token being bought\n     */\n    function _query(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut\n    ) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/router/adapters/uniswap/UniswapV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IUniswapV2Pair} from \"../interfaces/IUniswapV2Pair.sol\";\nimport {Adapter} from \"../../Adapter.sol\";\n\nimport {Address} from \"@openzeppelin/contracts-solc8/utils/Address.sol\";\n\n//solhint-disable reason-string\n\ncontract UniswapV2Adapter is Adapter {\n    // in base points\n    //solhint-disable-next-line\n    uint128 internal immutable MULTIPLIER_WITH_FEE;\n    uint128 internal constant MULTIPLIER = 10000;\n\n    address public immutable uniswapV2Factory;\n    bytes32 internal immutable initCodeHash;\n\n    /**\n     * @dev Default UniSwap fee is 0.3% = 30bp\n     * @param _fee swap fee, in base points\n     */\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _uniswapV2FactoryAddress,\n        bytes32 _initCodeHash,\n        uint256 _fee\n    ) Adapter(_name, _swapGasEstimate) {\n        require(\n            _fee < MULTIPLIER,\n            \"Fee is too high. Must be less than multiplier\"\n        );\n        MULTIPLIER_WITH_FEE = uint128(MULTIPLIER - _fee);\n        uniswapV2Factory = _uniswapV2FactoryAddress;\n        initCodeHash = _initCodeHash;\n    }\n\n    function _depositAddress(address _tokenIn, address _tokenOut)\n        internal\n        view\n        override\n        returns (address pair)\n    {\n        bytes32 salt = _tokenIn < _tokenOut\n            ? keccak256(abi.encodePacked(_tokenIn, _tokenOut))\n            : keccak256(abi.encodePacked(_tokenOut, _tokenIn));\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            uniswapV2Factory,\n                            salt,\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        address _pair = _depositAddress(_tokenIn, _tokenOut);\n\n        _amountOut = _getPairAmountOut(_pair, _tokenIn, _tokenOut, _amountIn);\n        require(_amountOut > 0, \"Adapter: Insufficient output amount\");\n\n        if (_tokenIn < _tokenOut) {\n            IUniswapV2Pair(_pair).swap(0, _amountOut, _to, new bytes(0));\n        } else {\n            IUniswapV2Pair(_pair).swap(_amountOut, 0, _to, new bytes(0));\n        }\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        address _pair = _depositAddress(_tokenIn, _tokenOut);\n\n        _amountOut = _getPairAmountOut(_pair, _tokenIn, _tokenOut, _amountIn);\n    }\n\n    function _getPairAmountOut(\n        address _pair,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn\n    ) internal view returns (uint256 _amountOut) {\n        if (Address.isContract(_pair)) {\n            try IUniswapV2Pair(_pair).getReserves() returns (\n                uint112 _reserve0,\n                uint112 _reserve1,\n                uint32\n            ) {\n                if (_tokenIn < _tokenOut) {\n                    _amountOut = _calcAmountOut(\n                        _amountIn,\n                        _reserve0,\n                        _reserve1\n                    );\n                } else {\n                    _amountOut = _calcAmountOut(\n                        _amountIn,\n                        _reserve1,\n                        _reserve0\n                    );\n                }\n            } catch {\n                this;\n            }\n        }\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _calcAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal view returns (uint256 _amountOut) {\n        if (_reserveIn == 0 || _reserveOut == 0) {\n            return 0;\n        }\n        uint256 amountInWithFee = _amountIn * MULTIPLIER_WITH_FEE;\n\n        _amountOut =\n            (amountInWithFee * _reserveOut) /\n            (_reserveIn * MULTIPLIER + amountInWithFee);\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function mint(address to) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/router/adapters/wrapper/WrapperAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Adapter} from \"../../Adapter.sol\";\n\nabstract contract WrapperAdapter is Adapter {\n    address public immutable tokenNative;\n    address public immutable tokenWrapped;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _tokenNative,\n        address _tokenWrapped\n    ) Adapter(_name, _swapGasEstimate) {\n        tokenNative = _tokenNative;\n        tokenWrapped = _tokenWrapped;\n    }\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            (_tokenIn == tokenNative || _tokenIn == tokenWrapped) &&\n            (_tokenOut == tokenNative || _tokenOut == tokenWrapped);\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        // both tokens are checked to be either A or B\n        // they are also checked to be different\n        if (_tokenIn == tokenNative) {\n            _amountOut = _swapNativeToWrapped(_amountIn, _to);\n        } else {\n            _amountOut = _swapWrappedToNative(_amountIn, _to);\n        }\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address\n    ) internal view virtual override returns (uint256 _amountOut) {\n        if (_isPaused()) {\n            return 0;\n        }\n        // both tokens are checked to be either A or B\n        // they are also checked to be different\n        if (_tokenIn == tokenNative) {\n            _amountOut = _queryNativeToWrapped(_amountIn);\n        } else {\n            _amountOut = _queryWrappedToNative(_amountIn);\n        }\n    }\n\n    // -- ABSTRACT FUNCTIONS --\n\n    function _isPaused() internal view virtual returns (bool);\n\n    function _swapNativeToWrapped(uint256 _amountIn, address _to)\n        internal\n        virtual\n        returns (uint256);\n\n    function _swapWrappedToNative(uint256 _amountIn, address _to)\n        internal\n        virtual\n        returns (uint256);\n\n    function _queryNativeToWrapped(uint256 _amountIn)\n        internal\n        view\n        virtual\n        returns (uint256);\n\n    function _queryWrappedToNative(uint256 _amountIn)\n        internal\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/router/adapters/wrapper/SynFraxAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {WrapperAdapter} from \"./WrapperAdapter.sol\";\n\nimport {IFrax} from \"../interfaces/IFrax.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ncontract SynFraxAdapter is WrapperAdapter {\n    // Constant for FRAX price precision\n    uint256 private constant PRICE_PRECISION = 1e6;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _frax,\n        address _synFrax\n    ) WrapperAdapter(_name, _swapGasEstimate, _frax, _synFrax) {\n        _setInfiniteAllowance(IERC20(_synFrax), _frax);\n\n        // Chad (FRAX) doesn't need your approval to burn FRAX\n    }\n\n    function _depositAddress(address, address)\n        internal\n        view\n        virtual\n        override\n        returns (address)\n    {\n        return address(this);\n    }\n\n    function _isPaused() internal view virtual override returns (bool) {\n        return\n            IFrax(tokenNative).exchangesPaused() ||\n            !IFrax(tokenNative).canSwap(tokenWrapped);\n    }\n\n    function _swapNativeToWrapped(uint256 _amountIn, address _to)\n        internal\n        virtual\n        override\n        returns (uint256 _amountOut)\n    {\n        _amountOut = IFrax(tokenNative).exchangeCanonicalForOld(\n            tokenWrapped,\n            _amountIn\n        );\n        _returnTo(tokenWrapped, _amountOut, _to);\n    }\n\n    function _swapWrappedToNative(uint256 _amountIn, address _to)\n        internal\n        virtual\n        override\n        returns (uint256 _amountOut)\n    {\n        _amountOut = IFrax(tokenNative).exchangeOldForCanonical(\n            tokenWrapped,\n            _amountIn\n        );\n        _returnTo(tokenNative, _amountOut, _to);\n    }\n\n    function _queryNativeToWrapped(uint256 _amountIn)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 _amountOut)\n    {\n        _amountOut = _amountIn;\n        if (!IFrax(tokenNative).fee_exempt_list(address(this))) {\n            _amountOut -=\n                (_amountOut * IFrax(tokenNative).swap_fees(tokenWrapped, 1)) /\n                PRICE_PRECISION;\n        }\n        if (IERC20(tokenWrapped).balanceOf(tokenNative) < _amountOut) {\n            // if FRAX contract doesn't have enough synFRAX, swap will fail\n            _amountOut = 0;\n        }\n    }\n\n    function _queryWrappedToNative(uint256 _amountIn)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 _amountOut)\n    {\n        _amountOut = _amountIn;\n        if (!IFrax(tokenNative).fee_exempt_list(address(this))) {\n            _amountOut -=\n                (_amountOut * IFrax(tokenNative).swap_fees(tokenWrapped, 0)) /\n                PRICE_PRECISION;\n        }\n        uint256 _newTotalSupply = IERC20(tokenNative).totalSupply() +\n            _amountOut;\n        if (IFrax(tokenNative).mint_cap() < _newTotalSupply) {\n            // Can't mint more FRAX than mint cap specifies, swap will fail\n            _amountOut = 0;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/IFrax.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IFrax {\n    // -- VIEWS --\n\n    function canSwap(address bridgeTokenAddress) external view returns (bool);\n\n    function exchangesPaused() external view returns (bool);\n\n    // solhint-disable-next-line\n    function fee_exempt_list(address swapper) external view returns (bool);\n\n    // solhint-disable-next-line\n    function swap_fees(address bridgeTokenAddress, uint256 direction)\n        external\n        view\n        returns (uint256);\n\n    // solhint-disable-next-line\n    function mint_cap() external view returns (uint256);\n\n    // -- SWAP --\n    function exchangeCanonicalForOld(\n        address bridgeTokenAddress,\n        uint256 tokenAmount\n    ) external returns (uint256 amountOut);\n\n    function exchangeOldForCanonical(\n        address bridgeTokenAddress,\n        uint256 tokenAmount\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/router/adapters/uniswap/UniswapV2AdapterSlow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IUniswapV2Factory} from \"../interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Pair} from \"../interfaces/IUniswapV2Pair.sol\";\n\nimport {Adapter} from \"../../Adapter.sol\";\n\n// solhint-disable reason-string\n\ncontract UniswapV2AdapterSlow is Adapter {\n    IUniswapV2Factory public uniswapV2Factory;\n\n    // storage for already known pairs\n    mapping(address => mapping(address => address)) private pairs;\n\n    // in base points\n    // solhint-disable-next-line\n    uint256 internal immutable MULTIPLIER_WITH_FEE;\n    uint256 internal constant MULTIPLIER = 10000;\n\n    /**\n     * @dev Default UniSwap fee is 0.3% = 30bp\n     * @param _fee swap fee, in base points\n     */\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _uniswapV2FactoryAddress,\n        uint256 _fee\n    ) Adapter(_name, _swapGasEstimate) {\n        require(\n            _fee < MULTIPLIER,\n            \"Fee is too high. Must be less than multiplier\"\n        );\n        MULTIPLIER_WITH_FEE = MULTIPLIER - _fee;\n        uniswapV2Factory = IUniswapV2Factory(_uniswapV2FactoryAddress);\n    }\n\n    function _approveIfNeeded(address, uint256) internal virtual override {\n        this;\n    }\n\n    function _depositAddress(address _tokenIn, address _tokenOut)\n        internal\n        view\n        override\n        returns (address)\n    {\n        return\n            pairs[_tokenIn][_tokenOut] == address(0)\n                ? uniswapV2Factory.getPair(_tokenIn, _tokenOut)\n                : pairs[_tokenIn][_tokenOut];\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        address _pair = _getPair(_tokenIn, _tokenOut);\n        // _amountIn and _pair are already checked\n        _amountOut = _getPairAmountOut(_pair, _tokenIn, _tokenOut, _amountIn);\n        require(_amountOut > 0, \"Adapter: Insufficient output amount\");\n        (uint256 _amount0Out, uint256 _amount1Out) = _tokenIn < _tokenOut\n            ? (uint256(0), _amountOut)\n            : (_amountOut, uint256(0));\n\n        IUniswapV2Pair(_pair).swap(_amount0Out, _amount1Out, _to, new bytes(0));\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        address _pair = _depositAddress(_tokenIn, _tokenOut);\n        // _pair is already checked\n        _amountOut = _getPairAmountOut(_pair, _tokenIn, _tokenOut, _amountIn);\n    }\n\n    function _getPair(address _tokenA, address _tokenB)\n        internal\n        returns (address)\n    {\n        if (pairs[_tokenA][_tokenB] == address(0)) {\n            address _pair = _depositAddress(_tokenA, _tokenB);\n\n            // save the pair address for both A->B and B->A directions\n            pairs[_tokenA][_tokenB] = _pair;\n            pairs[_tokenB][_tokenA] = _pair;\n        }\n        return pairs[_tokenA][_tokenB];\n    }\n\n    function _getReserves(\n        address _pair,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (uint256 _reserveA, uint256 _reserveB) {\n        (uint256 _reserve0, uint256 _reserve1, ) = IUniswapV2Pair(_pair)\n            .getReserves();\n        (_reserveA, _reserveB) = _tokenA < _tokenB\n            ? (_reserve0, _reserve1)\n            : (_reserve1, _reserve0);\n    }\n\n    function _getPairAmountOut(\n        address _pair,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn\n    ) internal view returns (uint256 _amountOut) {\n        (uint256 _reserveIn, uint256 _reserveOut) = _getReserves(\n            _pair,\n            _tokenIn,\n            _tokenOut\n        );\n        return _calcAmountOut(_amountIn, _reserveIn, _reserveOut);\n    }\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _depositAddress(_tokenIn, _tokenOut) != address(0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _calcAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal view returns (uint256 _amountOut) {\n        if (_reserveIn == 0 || _reserveOut == 0) {\n            return 0;\n        }\n        uint256 amountInWithFee = _amountIn * MULTIPLIER_WITH_FEE;\n        uint256 numerator = amountInWithFee * _reserveOut;\n        uint256 denominator = _reserveIn * MULTIPLIER + amountInWithFee;\n\n        _amountOut = numerator / denominator;\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n"
    },
    "contracts/router/adapters/synapse/SynapseBaseAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISynapse} from \"../interfaces/ISynapse.sol\";\nimport {Adapter} from \"../../Adapter.sol\";\nimport {SwapCalculator} from \"../../helper/SwapCalculator.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\n//solhint-disable not-rely-on-time\n\ncontract SynapseBaseAdapter is SwapCalculator, Adapter {\n    mapping(address => bool) public isPoolToken;\n    mapping(address => uint256) public tokenIndex;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool\n    ) SwapCalculator(ISynapse(_pool)) Adapter(_name, _swapGasEstimate) {\n        this;\n    }\n\n    function _addPoolToken(IERC20 token, uint256 index)\n        internal\n        virtual\n        override\n    {\n        SwapCalculator._addPoolToken(token, index);\n        _registerPoolToken(token, index);\n    }\n\n    function _registerPoolToken(IERC20 token, uint256 index) internal {\n        isPoolToken[address(token)] = true;\n        tokenIndex[address(token)] = index;\n        _setInfiniteAllowance(token, address(pool));\n    }\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return isPoolToken[_tokenIn] && isPoolToken[_tokenOut];\n    }\n\n    function _depositAddress(address, address)\n        internal\n        view\n        override\n        returns (address)\n    {\n        return address(this);\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = pool.swap(\n            uint8(tokenIndex[_tokenIn]),\n            uint8(tokenIndex[_tokenOut]),\n            _amountIn,\n            0,\n            block.timestamp\n        );\n\n        _returnTo(_tokenOut, _amountOut, _to);\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        if (pool.paused()) {\n            return 0;\n        }\n        try\n            pool.calculateSwap(\n                uint8(tokenIndex[_tokenIn]),\n                uint8(tokenIndex[_tokenOut]),\n                _amountIn\n            )\n        returns (uint256 amountOut) {\n            _amountOut = amountOut;\n        } catch {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/ISynapse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ninterface ISynapse {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getAPrecise() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    function paused() external view returns (bool);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount)\n        external\n        view\n        returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex\n    ) external view returns (uint256 availableTokenAmount);\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidityImbalance(\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function swapStorage()\n        external\n        view\n        returns (\n            uint256 initialA,\n            uint256 futureA,\n            uint256 initialATime,\n            uint256 futureATime,\n            uint256 swapFee,\n            uint256 adminFee,\n            address lpToken\n        );\n}\n"
    },
    "contracts/router/helper/SwapCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../adapters/interfaces/ISynapse.sol\";\n\ninterface IERC20Decimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract SwapCalculator {\n    // Struct storing variables used in calculations in the\n    // {add,remove}Liquidity functions to avoid stack too deep errors\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 preciseA;\n        uint256 totalSupply;\n        uint256[] balances;\n        uint256[] multipliers;\n    }\n\n    ISynapse public immutable pool;\n    IERC20 public immutable lpToken;\n    uint256 public immutable numTokens;\n    uint256 public swapFee;\n    uint256 private swapFeePerToken;\n\n    IERC20[] public poolTokens;\n    uint256[] private tokenPrecisionMultipliers;\n\n    uint8 private constant POOL_PRECISION_DECIMALS = 18;\n    uint256 private constant A_PRECISION = 100;\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    constructor(ISynapse _pool) {\n        pool = _pool;\n        (, , , , uint256 _swapFee, , address _lpToken) = _pool.swapStorage();\n        lpToken = IERC20(_lpToken);\n        // set numTokens prior to swapFee\n        numTokens = _setPoolTokens(_pool);\n        _setSwapFee(_swapFee);\n    }\n\n    function updateSwapFee() external {\n        (, , , , uint256 _swapFee, , ) = pool.swapStorage();\n        _setSwapFee(_swapFee);\n    }\n\n    function calculateAddLiquidity(uint256[] memory _amounts)\n        public\n        view\n        returns (uint256)\n    {\n        require(\n            _amounts.length == numTokens,\n            \"Amounts must match pooled tokens\"\n        );\n        uint256 _numTokens = numTokens;\n\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            pool.getAPrecise(),\n            lpToken.totalSupply(),\n            new uint256[](_numTokens),\n            tokenPrecisionMultipliers\n        );\n\n        uint256[] memory newBalances = new uint256[](_numTokens);\n\n        for (uint8 _i = 0; _i < _numTokens; _i++) {\n            v.balances[_i] = ISynapse(pool).getTokenBalance(_i);\n            newBalances[_i] = v.balances[_i] + _amounts[_i];\n        }\n\n        if (v.totalSupply != 0) {\n            v.d0 = _getD(_xp(v.balances, v.multipliers), v.preciseA);\n        } else {\n            // pool is empty => all amounts must be >0\n            for (uint8 i = 0; i < _numTokens; i++) {\n                require(_amounts[i] > 0, \"Must supply all tokens in pool\");\n            }\n        }\n\n        // invariant after change\n        v.d1 = _getD(_xp(newBalances, v.multipliers), v.preciseA);\n        require(v.d1 > v.d0, \"D should increase\");\n\n        if (v.totalSupply == 0) {\n            return v.d1;\n        } else {\n            for (uint256 _i = 0; _i < _numTokens; _i++) {\n                uint256 idealBalance = (v.d1 * v.balances[_i]) / v.d0;\n                uint256 fees = (swapFeePerToken *\n                    _diff(newBalances[_i], idealBalance)) / FEE_DENOMINATOR;\n                newBalances[_i] = newBalances[_i] - fees;\n            }\n            v.d1 = _getD(_xp(newBalances, v.multipliers), v.preciseA);\n            return ((v.d1 - v.d0) * v.totalSupply) / v.d0;\n        }\n    }\n\n    function _setPoolTokens(ISynapse _pool) internal returns (uint256) {\n        for (uint8 i = 0; true; i++) {\n            try _pool.getToken(i) returns (IERC20 token) {\n                _addPoolToken(token, i);\n            } catch {\n                break;\n            }\n        }\n        return tokenPrecisionMultipliers.length;\n    }\n\n    function _addPoolToken(IERC20 token, uint256) internal virtual {\n        IERC20Decimals _token = IERC20Decimals(address(token));\n        tokenPrecisionMultipliers.push(\n            10**uint256(POOL_PRECISION_DECIMALS - _token.decimals())\n        );\n        poolTokens.push(token);\n    }\n\n    function _setSwapFee(uint256 _swapFee) internal {\n        swapFee = _swapFee;\n        swapFeePerToken = (swapFee * numTokens) / ((numTokens - 1) * 4);\n    }\n\n    /**\n     * @notice Get absolute difference between two values\n     * @return abs(_a - _b)\n     */\n    function _diff(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        if (_a > _b) {\n            return _a - _b;\n        } else {\n            return _b - _a;\n        }\n    }\n\n    /**\n     * @notice Get pool balances adjusted, as if all tokens had 18 decimals\n     */\n    function _xp(\n        uint256[] memory balances,\n        uint256[] memory precisionMultipliers\n    ) internal pure returns (uint256[] memory) {\n        uint256 _numTokens = balances.length;\n        require(\n            _numTokens == precisionMultipliers.length,\n            \"Balances must match multipliers\"\n        );\n        uint256[] memory xp = new uint256[](_numTokens);\n        for (uint256 i = 0; i < _numTokens; i++) {\n            xp[i] = balances[i] * precisionMultipliers[i];\n        }\n        return xp;\n    }\n\n    /**\n     * @notice Get D: pool invariant\n     */\n    function _getD(uint256[] memory xp, uint256 a)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 _numTokens = xp.length;\n        uint256 s;\n        for (uint256 _i = 0; _i < _numTokens; _i++) {\n            s = s + xp[_i];\n        }\n        if (s == 0) {\n            return 0;\n        }\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a * _numTokens;\n\n        for (uint256 _i = 0; _i < 256; _i++) {\n            uint256 dP = d;\n            for (uint256 j = 0; j < _numTokens; j++) {\n                dP = (dP * d) / (xp[j] * _numTokens);\n                // If we were to protect the division loss we would have to keep the denominator separate\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\n                // dP = dP * D * D * D * ... overflow!\n            }\n            prevD = d;\n            d =\n                (((nA * s) / A_PRECISION + dP * _numTokens) * d) /\n                (((nA - A_PRECISION) * d) /\n                    A_PRECISION +\n                    (_numTokens + 1) *\n                    dP);\n\n            if (_diff(d, prevD) <= 1) {\n                return d;\n            }\n        }\n\n        revert(\"D does not converge\");\n    }\n}\n"
    },
    "contracts/router/adapters/synapse/SynapseBaseMainnetAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SynapseBaseAdapter} from \"./SynapseBaseAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\n//solhint-disable not-rely-on-time\n\ncontract SynapseBaseMainnetAdapter is SynapseBaseAdapter {\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool\n    ) SynapseBaseAdapter(_name, _swapGasEstimate, _pool) {\n        // add LP token as a \"pool token\"\n        // This will enable stable <-> nUSD swap on Mainnet via adapter\n        _registerPoolToken(lpToken, numTokens);\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        uint8 _indexIn = uint8(tokenIndex[_tokenIn]);\n        uint8 _indexOut = uint8(tokenIndex[_tokenOut]);\n\n        if (_indexIn == numTokens) {\n            // remove liquidity\n            _amountOut = pool.removeLiquidityOneToken(\n                _amountIn,\n                _indexOut,\n                0,\n                block.timestamp\n            );\n        } else if (_indexOut == numTokens) {\n            // add liquidity\n            uint256[] memory amounts = new uint256[](numTokens);\n            amounts[_indexIn] = _amountIn;\n\n            _amountOut = pool.addLiquidity(amounts, 0, block.timestamp);\n        } else {\n            // swap tokens\n            _amountOut = pool.swap(\n                _indexIn,\n                _indexOut,\n                _amountIn,\n                0,\n                block.timestamp\n            );\n        }\n        _returnTo(_tokenOut, _amountOut, _to);\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        if (pool.paused()) {\n            return 0;\n        }\n        uint8 _indexIn = uint8(tokenIndex[_tokenIn]);\n        uint8 _indexOut = uint8(tokenIndex[_tokenOut]);\n\n        if (_indexIn == numTokens) {\n            // remove liquidity\n            try\n                pool.calculateRemoveLiquidityOneToken(_amountIn, _indexOut)\n            returns (uint256 amountOut) {\n                _amountOut = amountOut;\n            } catch {\n                return 0;\n            }\n        } else if (_indexOut == numTokens) {\n            // add liquidity\n            uint256[] memory _amounts = new uint256[](numTokens);\n            _amounts[_indexIn] = _amountIn;\n\n            _amountOut = calculateAddLiquidity(_amounts);\n        } else {\n            // swap tokens\n            try pool.calculateSwap(_indexIn, _indexOut, _amountIn) returns (\n                uint256 amountOut\n            ) {\n                _amountOut = amountOut;\n            } catch {\n                return 0;\n            }\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/synapse/SynapseAaveAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {SynapseBaseAdapter} from \"./SynapseBaseAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ninterface AaveToken is IERC20 {\n    function scaledBalanceOf(address user) external view returns (uint256);\n}\n\ncontract SynapseAaveAdapter is SynapseBaseAdapter {\n    ILendingPool public immutable lendingPool;\n\n    mapping(address => address) public aaveToken;\n    mapping(address => bool) public isUnderlying;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = RAY / 2;\n\n    /**\n     * @param _name Adapter name\n     * @param _swapGasEstimate Estimated gas usage for this.swap()\n     * @param _pool Pool address\n     * @param _lendingPool Aave lending pool address\n     * @param _underlyingTokens underlying pool tokens, that will be traded\n     */\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        address _lendingPool,\n        address[] memory _underlyingTokens\n    ) SynapseBaseAdapter(_name, _swapGasEstimate, _pool) {\n        require(_underlyingTokens.length == numTokens, \"Wrong tokens amount\");\n        lendingPool = ILendingPool(_lendingPool);\n\n        for (uint8 i = 0; i < _underlyingTokens.length; i++) {\n            address _poolToken = address(poolTokens[i]);\n            if (_poolToken != _underlyingTokens[i]) {\n                _registerUnderlyingToken(_underlyingTokens[i], _poolToken);\n            }\n        }\n    }\n\n    function _registerUnderlyingToken(address _underlying, address _poolToken)\n        internal\n    {\n        aaveToken[_underlying] = _poolToken;\n        isUnderlying[_underlying] = true;\n        _setInfiniteAllowance(IERC20(_underlying), address(lendingPool));\n    }\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        // Swaps are supported between both pool and underlying tokens\n        return\n            (isUnderlying[_tokenIn] || isPoolToken[_tokenIn]) &&\n            (isUnderlying[_tokenOut] || isPoolToken[_tokenOut]);\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        if (isUnderlying[_tokenIn]) {\n            // Approval already granted in _approveIfNeeded()\n            _amountIn = _aaveDeposit(_tokenIn, _amountIn);\n            // Swap pool can only trade aToken\n            _tokenIn = aaveToken[_tokenIn];\n        }\n        if (isUnderlying[_tokenOut]) {\n            // User needs to receive underlying token, so we ask the aToken to be sent to this contract\n            SynapseBaseAdapter._swap(\n                _amountIn,\n                _tokenIn,\n                aaveToken[_tokenOut],\n                address(this)\n            );\n            // Withdraw underlying token directly to user\n            _amountOut = _aaveWithdraw(_tokenOut, UINT_MAX, _to);\n        } else {\n            // User needs to receive pool token, so we can use parent's logic\n            _amountOut = SynapseBaseAdapter._swap(\n                _amountIn,\n                _tokenIn,\n                _tokenOut,\n                _to\n            );\n        }\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        if (isUnderlying[_tokenIn]) {\n            // figure out how much aTokens will be transferred\n            // as pool contract is comparing balances pre/post transfer\n            _amountIn = _calcTransferredIn(_amountIn, _tokenIn);\n            // replace _tokenIn with actual pool token\n            _tokenIn = aaveToken[_tokenIn];\n        }\n\n        if (isUnderlying[_tokenOut]) {\n            uint256 _index = lendingPool.getReserveNormalizedIncome(_tokenOut);\n            // replace _tokenOut with actual pool token\n            _tokenOut = aaveToken[_tokenOut];\n            _amountOut = SynapseBaseAdapter._query(\n                _amountIn,\n                _tokenIn,\n                _tokenOut\n            );\n\n            _amountOut = _calcTransferredOut(_amountOut, _index);\n        } else {\n            _amountOut = SynapseBaseAdapter._query(\n                _amountIn,\n                _tokenIn,\n                _tokenOut\n            );\n        }\n    }\n\n    // -- AAVE FUNCTIONS\n\n    /// https://github.com/aave/protocol-v2/blob/master/contracts/protocol/libraries/math/WadRayMath.sol\n    function _calcTransferredOut(uint256 _amount, uint256 _index)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 rayDiv = (_amount * RAY + _index / 2) / _index;\n        return (rayDiv * _index + HALF_RAY) / RAY;\n    }\n\n    function _calcTransferredIn(uint256 _amount, address _token)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _index = lendingPool.getReserveNormalizedIncome(_token);\n\n        uint256 _delta = (_amount * RAY + _index / 2) / _index;\n        uint256 _oldScaledBalance = AaveToken(aaveToken[_token])\n            .scaledBalanceOf(address(pool));\n\n        uint256 _newScaledBalance = _oldScaledBalance + _delta;\n\n        uint256 _oldBalance = (_oldScaledBalance * _index + HALF_RAY) / RAY;\n        uint256 _newBalance = (_newScaledBalance * _index + HALF_RAY) / RAY;\n\n        return _newBalance - _oldBalance;\n    }\n\n    /**\n     * @notice Deposits token into Aave and receives aToken\n     *\n     * @dev lendingPool should have approval for spending underlying token\n     *\n     * @param _token underlying token to deposit\n     * @param _amount amount of token to deposit\n     *\n     * @return amount of aToken received\n     */\n    function _aaveDeposit(address _token, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        lendingPool.deposit(_token, _amount, address(this), 0);\n        return IERC20(aaveToken[_token]).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Withdraw token from Aave and send underlying token to user\n     *\n     * @dev Chad (lendingPool) doesn't need your approval to spend your aToken.\n     * \t\tUse [_to = address(this);] if token needs further (un)wrapping\n     *      Use [_amount = UINT_MAX] to withdraw all aToken balance\n     *\n     * @param _token underlying token to withdraw\n     * @param _amount amount of token to withdraw\n     * @param _to address that will receive underlying token\n     *\n     * @return amount of underlying token withdrawn\n     */\n    function _aaveWithdraw(\n        address _token,\n        uint256 _amount,\n        address _to\n    ) internal returns (uint256) {\n        return lendingPool.withdraw(_token, _amount, _to);\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ILendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n\t/**\n\t* @dev Returns the normalized income per unit of asset\n\t* @param asset The address of the underlying asset of the reserve\n\t* @return The reserve's normalized income\n\t*/\n\tfunction getReserveNormalizedIncome(address asset) external view returns (uint256);\n}"
    },
    "contracts/router/adapters/platipus/PlatypusAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Adapter} from \"../../Adapter.sol\";\n\nimport {IPlatypusPool} from \"../interfaces/IPlatypusPool.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ncontract PlatypusAdapter is Adapter {\n    IPlatypusPool public immutable pool;\n    mapping(address => bool) public isPoolToken;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool\n    ) Adapter(_name, _swapGasEstimate) {\n        pool = IPlatypusPool(_pool);\n        _setPoolTokens();\n    }\n\n    function _setPoolTokens() internal {\n        address[] memory poolTokens = pool.getTokenAddresses();\n        for (uint8 i = 0; i < poolTokens.length; ++i) {\n            address _token = poolTokens[i];\n            isPoolToken[_token] = true;\n            _setInfiniteAllowance(IERC20(_token), address(pool));\n        }\n    }\n\n    // -- BASE ADAPTER FUNCTIONS\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return isPoolToken[_tokenIn] && isPoolToken[_tokenOut];\n    }\n\n    function _depositAddress(address, address)\n        internal\n        view\n        override\n        returns (address)\n    {\n        return address(this);\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        // solhint-disable not-rely-on-time\n        (_amountOut, ) = pool.swap(\n            _tokenIn,\n            _tokenOut,\n            _amountIn,\n            0,\n            _to,\n            block.timestamp\n        );\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        if (pool.paused()) {\n            return 0;\n        }\n        try pool.quotePotentialSwap(_tokenIn, _tokenOut, _amountIn) returns (\n            uint256 amountOut,\n            uint256\n        ) {\n            _amountOut = amountOut;\n        } catch {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/IPlatypusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPlatypusPool {\n    // -- VIEWS --\n    function getTokenAddresses() external view returns (address[] memory);\n\n    function paused() external view returns (bool);\n\n    function quotePotentialSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view returns (uint256 potentialOutcome, uint256 haircut);\n\n    // -- SWAP --\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 actualToAmount, uint256 haircut);\n}\n"
    },
    "contracts/router/adapters/gmx/GmxAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Adapter} from \"../../Adapter.sol\";\n\nimport {IGmxReader} from \"../interfaces/IGmxReader.sol\";\nimport {IGmxVault} from \"../interfaces/IGmxVault.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ncontract GmxAdapter is Adapter {\n    IGmxVault public immutable vault;\n    IGmxReader public immutable reader;\n\n    mapping(address => bool) public isPoolToken;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _vault,\n        address _reader\n    ) Adapter(_name, _swapGasEstimate) {\n        vault = IGmxVault(_vault);\n        reader = IGmxReader(_reader);\n        _setPoolTokens();\n    }\n\n    function _setPoolTokens() internal {\n        uint256 _amount = vault.allWhitelistedTokensLength();\n        for (uint256 index = 0; index < _amount; ++index) {\n            address _token = vault.allWhitelistedTokens(index);\n            isPoolToken[_token] = true;\n        }\n    }\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return isPoolToken[_tokenIn] && isPoolToken[_tokenOut];\n    }\n\n    function _depositAddress(address, address)\n        internal\n        view\n        override\n        returns (address)\n    {\n        return address(vault);\n    }\n\n    function _swap(\n        uint256,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = vault.swap(_tokenIn, _tokenOut, _to);\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        try reader.getMaxAmountIn(address(vault), _tokenIn, _tokenOut) returns (\n            uint256 maxAmountIn\n        ) {\n            if (_amountIn > maxAmountIn) {\n                return 0;\n            }\n        } catch {\n            return 0;\n        }\n\n        try\n            reader.getAmountOut(address(vault), _tokenIn, _tokenOut, _amountIn)\n        returns (uint256 amountOutAfterFees, uint256) {\n            _amountOut = amountOutAfterFees;\n        } catch {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/interfaces/IGmxReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGmxReader {\n    function getMaxAmountIn(\n        address _vault,\n        address _tokenIn,\n        address _tokenOut\n    ) external view returns (uint256 maxAmountIn);\n\n    function getAmountOut(\n        address _vault,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _amountIn\n    ) external view returns (uint256 amountOutAfterFees, uint256 feeAmount);\n}\n"
    },
    "contracts/router/adapters/interfaces/IGmxVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGmxVault {\n    // -- VIEWS --\n    function allWhitelistedTokens(uint256 _index)\n        external\n        view\n        returns (address);\n\n    function allWhitelistedTokensLength() external view returns (uint256);\n\n    // -- SWAP --\n    function swap(\n        address _tokenIn,\n        address _tokenOut,\n        address _receiver\n    ) external returns (uint256);\n}\n"
    },
    "contracts/router/adapters/curve/CurveAbstractAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Adapter} from \"../../Adapter.sol\";\n\nimport {ICurvePool} from \"../interfaces/ICurvePool.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\nabstract contract CurveAbstractAdapter is Adapter {\n    ICurvePool public immutable pool;\n    bool internal immutable directSwapSupported;\n\n    mapping(address => bool) public isPoolToken;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        bool _directSwapSupported\n    ) Adapter(_name, _swapGasEstimate) {\n        pool = ICurvePool(_pool);\n        directSwapSupported = _directSwapSupported;\n        _setPoolTokens();\n    }\n\n    function _setPoolTokens() internal virtual {\n        for (uint8 i = 0; true; i++) {\n            try pool.coins(i) returns (address _tokenAddress) {\n                _addPoolToken(_tokenAddress, i);\n                _setInfiniteAllowance(IERC20(_tokenAddress), address(pool));\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _addPoolToken(address _tokenAddress, uint8 _index)\n        internal\n        virtual;\n\n    function _checkTokens(address _tokenIn, address _tokenOut)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return isPoolToken[_tokenIn] && isPoolToken[_tokenOut];\n    }\n\n    function _depositAddress(address, address)\n        internal\n        view\n        virtual\n        override\n        returns (address)\n    {\n        return address(this);\n    }\n\n    function _swap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        if (directSwapSupported) {\n            _amountOut = _doDirectSwap(_amountIn, _tokenIn, _tokenOut, _to);\n        } else {\n            _amountOut = _doIndirectSwap(_amountIn, _tokenIn, _tokenOut);\n            _returnTo(_tokenOut, _amountOut, _to);\n        }\n    }\n\n    function _doDirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual returns (uint256);\n\n    function _doIndirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal virtual returns (uint256);\n}\n"
    },
    "contracts/router/adapters/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ICurvePool {\n    // Coin getters\n\n    function coins(uint256 arg0) external view returns (address);\n\n    function base_coins(uint256 arg0) external view returns (address);\n\n    function underlying_coins(uint256 arg0) external view returns (address);\n\n    // Quote functions (int128)\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    // Quote functions (uint256)\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    // Swap functions (int128)\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    // Swap functions (uint256)\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external;\n\n    function exchange_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external;\n}\n"
    },
    "contracts/router/adapters/curve/CurveTriCryptoAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CurveAbstractAdapter} from \"./CurveAbstractAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ncontract CurveTriCryptoAdapter is CurveAbstractAdapter {\n    /**\n        @dev TriCrypto Adapter is using uint256 for indexes\n        and is using exchange() for swaps\n     */\n\n    mapping(address => uint256) public tokenIndex;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        bool _directSwapSupported\n    )\n        CurveAbstractAdapter(\n            _name,\n            _swapGasEstimate,\n            _pool,\n            _directSwapSupported\n        )\n    {\n        this;\n    }\n\n    function _addPoolToken(address _tokenAddress, uint8 _index)\n        internal\n        virtual\n        override\n    {\n        isPoolToken[_tokenAddress] = true;\n        tokenIndex[_tokenAddress] = _index;\n    }\n\n    function _doDirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = IERC20(_tokenOut).balanceOf(_to);\n        pool.exchange(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0,\n            _to\n        );\n        _amountOut = IERC20(_tokenOut).balanceOf(_to) - _amountOut;\n    }\n\n    function _doIndirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal virtual override returns (uint256 _amountOut) {\n        pool.exchange(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0\n        );\n        // Imagine not returning amount of swapped tokens\n        _amountOut = IERC20(_tokenOut).balanceOf(address(this));\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        try\n            pool.get_dy(tokenIndex[_tokenIn], tokenIndex[_tokenOut], _amountIn)\n        returns (uint256 _amt) {\n            // -1 to account for rounding errors.\n            // This will underquote by 1 wei sometimes, but that's life\n            _amountOut = _amt != 0 ? _amt - 1 : 0;\n        } catch {\n            _amountOut = 0;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/curve/CurveLendingTriCryptoAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CurveAbstractAdapter} from \"./CurveAbstractAdapter.sol\";\n\nimport {ICurvePool} from \"../interfaces/ICurvePool.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ncontract CurveLendingTriCryptoAdapter is CurveAbstractAdapter {\n    /**\n        @dev Lending TriCrypto Adapter is using uint256 for indexes\n        and is using exchange_underlying() for swaps\n     */\n\n    uint256 private immutable numberStablecoins;\n\n    mapping(address => uint256) public tokenIndex;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        bool _directSwapSupported,\n        address _basePool\n    )\n        CurveAbstractAdapter(\n            _name,\n            _swapGasEstimate,\n            _pool,\n            _directSwapSupported\n        )\n    {\n        numberStablecoins = _getBasePoolSize(_basePool);\n    }\n\n    function _setPoolTokens() internal virtual override {\n        for (uint8 i = 0; true; i++) {\n            try pool.underlying_coins(i) returns (address _tokenAddress) {\n                _addPoolToken(_tokenAddress, i);\n                _setInfiniteAllowance(IERC20(_tokenAddress), address(pool));\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _addPoolToken(address _tokenAddress, uint8 _index)\n        internal\n        virtual\n        override\n    {\n        isPoolToken[_tokenAddress] = true;\n        tokenIndex[_tokenAddress] = _index;\n    }\n\n    function _getBasePoolSize(address _basePoolAddress)\n        internal\n        view\n        returns (uint256 _numCoins)\n    {\n        ICurvePool _basePool = ICurvePool(_basePoolAddress);\n        _numCoins = 0;\n        for (;;) {\n            try _basePool.coins(_numCoins) {\n                _numCoins++;\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _doDirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = IERC20(_tokenOut).balanceOf(_to);\n        pool.exchange_underlying(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0,\n            _to\n        );\n        _amountOut = IERC20(_tokenOut).balanceOf(_to) - _amountOut;\n    }\n\n    function _doIndirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal virtual override returns (uint256 _amountOut) {\n        pool.exchange_underlying(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0\n        );\n        // Imagine not returning amount of swapped tokens\n        _amountOut = IERC20(_tokenOut).balanceOf(address(this));\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        try\n            pool.get_dy_underlying(\n                tokenIndex[_tokenIn],\n                tokenIndex[_tokenOut],\n                _amountIn\n            )\n        returns (uint256 _amt) {\n            // -1 to account for rounding errors.\n            // This will underquote by 1 wei sometimes, but that's life\n            _amountOut = _amt != 0 ? _amt - 1 : 0;\n        } catch {\n            return 0;\n        }\n\n        // quote for swaps from [base pool token] to [meta pool token] is\n        // sometimes overly optimistic. Subtracting 4 bp should give\n        // a more accurate lower bound for actual amount of tokens swapped\n        if (tokenIndex[_tokenIn] < numberStablecoins) {\n            _amountOut = (_amountOut * 9996) / 10000;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/curve/CurveMetaAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CurveLendingAdapter} from \"./CurveLendingAdapter.sol\";\n\nimport {ICurvePool} from \"../interfaces/ICurvePool.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts-4.4.2/utils/math/SafeCast.sol\";\n\ncontract CurveMetaAdapter is CurveLendingAdapter {\n    /**\n        @dev Meta Adapter is using int128 for indexes\n        and is using exchange_underlying() for swaps.\n        Exactly the same as Lending Adapter,\n        so _swap() implementation stays the same\n    */\n\n    // (MetaPoolToken, BasePool LP Token)\n    // (MetaPoolToken, [BasePoolToken 1, BasePoolToken 2, BasePoolToken 3])\n    //                      ^\n    //                      |\n    // index of first base pool token, most of the time = 1\n    int128 private firstBaseIndex;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        bool _directSwapSupported,\n        address _basePool\n    )\n        CurveLendingAdapter(\n            _name,\n            _swapGasEstimate,\n            _pool,\n            _directSwapSupported\n        )\n    {\n        _addBasePoolTokens(_basePool);\n    }\n\n    function _setPoolTokens() internal virtual override {\n        address _lastToken;\n        int128 _numTokens = 0;\n        for (uint8 i = 0; true; i++) {\n            try pool.coins(i) returns (address _tokenAddress) {\n                _addPoolToken(_tokenAddress, i);\n                _lastToken = _tokenAddress;\n                _numTokens++;\n\n                _setInfiniteAllowance(IERC20(_tokenAddress), address(pool));\n            } catch {\n                break;\n            }\n        }\n        // remove last token aka LP token for base pool\n        isPoolToken[_lastToken] = false;\n        tokenIndex[_lastToken] = 0;\n        firstBaseIndex = _numTokens - 1;\n    }\n\n    function _addBasePoolTokens(address _basePoolAddress) internal {\n        uint8 _numTokens = SafeCast.toUint8(SafeCast.toUint256(firstBaseIndex));\n        ICurvePool _basePool = ICurvePool(_basePoolAddress);\n        for (uint8 i = 0; true; i++) {\n            try _basePool.coins(i) returns (address _tokenAddress) {\n                _addPoolToken(_tokenAddress, _numTokens);\n                _numTokens++;\n\n                _setInfiniteAllowance(IERC20(_tokenAddress), address(pool));\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        try\n            pool.get_dy_underlying(\n                tokenIndex[_tokenIn],\n                tokenIndex[_tokenOut],\n                _amountIn\n            )\n        returns (uint256 _amt) {\n            // -1 to account for rounding errors.\n            // This will underquote by 1 wei sometimes, but that's life\n            _amountOut = _amt != 0 ? _amt - 1 : 0;\n        } catch {\n            return 0;\n        }\n\n        // quote for swaps from [base pool token] to [meta pool token] is\n        // sometimes overly optimistic. Subtracting 1 bp should give\n        // a more accurate lower bound for actual amount of tokens swapped\n        if (\n            tokenIndex[_tokenIn] >= firstBaseIndex &&\n            tokenIndex[_tokenOut] < firstBaseIndex\n        ) {\n            _amountOut = (_amountOut * 9999) / 10000;\n        }\n    }\n}\n"
    },
    "contracts/router/adapters/curve/CurveLendingAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CurveBaseAdapter} from \"./CurveBaseAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\n\ncontract CurveLendingAdapter is CurveBaseAdapter {\n    /**\n        @dev Base Adapter is using int128 for indexes\n        and is using exchange_underlying() for swaps\n     */\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        bool _directSwapSupported\n    ) CurveBaseAdapter(_name, _swapGasEstimate, _pool, _directSwapSupported) {\n        this;\n    }\n\n    function _setPoolTokens() internal virtual override {\n        for (uint8 i = 0; true; i++) {\n            try pool.underlying_coins(i) returns (address _tokenAddress) {\n                _addPoolToken(_tokenAddress, i);\n                _setInfiniteAllowance(IERC20(_tokenAddress), address(pool));\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _doDirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = pool.exchange_underlying(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0,\n            _to\n        );\n    }\n\n    function _doIndirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = pool.exchange_underlying(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0\n        );\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        try\n            pool.get_dy_underlying(\n                tokenIndex[_tokenIn],\n                tokenIndex[_tokenOut],\n                _amountIn\n            )\n        returns (uint256 _amt) {\n            // -1 to account for rounding errors.\n            // This will underquote by 1 wei sometimes, but that's life\n            _amountOut = _amt != 0 ? _amt - 1 : 0;\n        } catch {\n            _amountOut = 0;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.4.2/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/router/adapters/curve/CurveBaseAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CurveAbstractAdapter} from \"./CurveAbstractAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts-4.4.2/utils/math/SafeCast.sol\";\n\ncontract CurveBaseAdapter is CurveAbstractAdapter {\n    /**\n        @dev Base Adapter is using int128 for indexes\n        and is using exchange() for swaps\n     */\n\n    mapping(address => int128) public tokenIndex;\n\n    constructor(\n        string memory _name,\n        uint256 _swapGasEstimate,\n        address _pool,\n        bool _directSwapSupported\n    )\n        CurveAbstractAdapter(\n            _name,\n            _swapGasEstimate,\n            _pool,\n            _directSwapSupported\n        )\n    {\n        this;\n    }\n\n    function _addPoolToken(address _tokenAddress, uint8 _index)\n        internal\n        virtual\n        override\n    {\n        isPoolToken[_tokenAddress] = true;\n        tokenIndex[_tokenAddress] = SafeCast.toInt128(\n            SafeCast.toInt256(_index)\n        );\n    }\n\n    function _doDirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        address _to\n    ) internal virtual override returns (uint256 _amountOut) {\n        _amountOut = IERC20(_tokenOut).balanceOf(_to);\n        pool.exchange(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0,\n            _to\n        );\n        _amountOut = IERC20(_tokenOut).balanceOf(_to) - _amountOut;\n    }\n\n    function _doIndirectSwap(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal virtual override returns (uint256 _amountOut) {\n        pool.exchange(\n            tokenIndex[_tokenIn],\n            tokenIndex[_tokenOut],\n            _amountIn,\n            0\n        );\n        // Imagine not returning amount of swapped tokens\n        _amountOut = IERC20(_tokenOut).balanceOf(address(this));\n    }\n\n    function _query(\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut\n    ) internal view virtual override returns (uint256 _amountOut) {\n        try\n            pool.get_dy(tokenIndex[_tokenIn], tokenIndex[_tokenOut], _amountIn)\n        returns (uint256 _amt) {\n            // -1 to account for rounding errors.\n            // This will underquote by 1 wei sometimes, but that's life\n            _amountOut = _amt != 0 ? _amt - 1 : 0;\n        } catch {\n            _amountOut = 0;\n        }\n    }\n}\n"
    },
    "contracts/router/helper/test/TestAdapterSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAdapter} from \"../../interfaces/IAdapter.sol\";\n\nimport {IERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/IERC20.sol\";\nimport {SafeERC20} from \"@synapseprotocol/sol-lib/contracts/solc8/erc20/SafeERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract TestAdapterSwap {\n    using SafeERC20 for IERC20;\n\n    uint256 maxUnderQuote;\n\n    constructor(uint256 _maxUnderQuote) {\n        maxUnderQuote = _maxUnderQuote;\n    }\n\n    function testSwap(\n        IAdapter _adapter,\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        bool _checkUnderQuoting,\n        uint256 _iteration\n    ) external {\n        address depositAddress = _adapter.depositAddress(_tokenIn, _tokenOut);\n        IERC20(_tokenIn).safeTransferFrom(\n            msg.sender,\n            depositAddress,\n            _amountIn\n        );\n\n        uint256 amountQuoted = _adapter.query(_amountIn, _tokenIn, _tokenOut);\n\n        uint256 amountSwapped = 0;\n\n        try\n            _adapter.swap(_amountIn, _tokenIn, _tokenOut, address(this))\n        returns (uint256 _amount) {\n            amountSwapped = _amount;\n        } catch {\n            console.log(\"%s: %s -> %s\", _iteration, _tokenIn, _tokenOut);\n            console.log(\"%s\", _amountIn);\n            _adapter.swap(_amountIn, _tokenIn, _tokenOut, address(this));\n        }\n        uint256 amountReceived = IERC20(_tokenOut).balanceOf(address(this));\n\n        if (amountSwapped != amountReceived) {\n            console.log(\"Swap # %s\", _iteration);\n            console.log(\n                \"swap: Expected %s, got %s\",\n                amountSwapped,\n                amountReceived\n            );\n            revert(\"swap() failed to return amount of tokens\");\n        }\n\n        if (\n            amountQuoted > amountReceived ||\n            (amountQuoted + maxUnderQuote < amountReceived &&\n                _checkUnderQuoting)\n        ) {\n            console.log(\"Swap # %s\", _iteration);\n            if (amountQuoted > amountReceived) {\n                console.log(\n                    \"swap: (over)Quoted %s, got %s (diff: %s)\",\n                    amountQuoted,\n                    amountReceived,\n                    amountQuoted - amountReceived\n                );\n            } else {\n                console.log(\n                    \"swap: (under)Quoted %s, got %s (diff: %s)\",\n                    amountQuoted,\n                    amountReceived,\n                    amountReceived - amountQuoted\n                );\n            }\n            revert(\"query() failed to provide a good quote\");\n        }\n\n        IERC20(_tokenOut).safeTransfer(msg.sender, amountReceived);\n    }\n}\n"
    },
    "contracts/bridge/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.0;\n\ninterface IWETH9 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n\n    receive() external payable;\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n}"
    },
    "contracts/amm/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.0;\n\ninterface IWETH9 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n\n    receive() external payable;\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}