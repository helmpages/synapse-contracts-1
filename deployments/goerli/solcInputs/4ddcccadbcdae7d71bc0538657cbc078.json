{
  "language": "Solidity",
  "sources": {
    "contracts/messaging/MessageBus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-4.5.0/access/Ownable.sol\";\nimport \"./MessageBusSender.sol\";\nimport \"./MessageBusReceiver.sol\";\n\ncontract MessageBus is MessageBusSender, MessageBusReceiver {\n    constructor(address _gasFeePricing, address _authVerifier)\n        MessageBusSender(_gasFeePricing)\n        MessageBusReceiver(_authVerifier)\n    {}\n}\n"
    },
    "@openzeppelin/contracts-4.5.0/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/messaging/MessageBusSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-4.5.0/access/Ownable.sol\";\nimport \"./interfaces/IGasFeePricing.sol\";\n\ncontract MessageBusSender is Ownable {\n    address public gasFeePricing;\n    uint64 public nonce;\n    uint256 internal fees;\n\n    constructor(address _gasFeePricing) {\n        gasFeePricing = _gasFeePricing;\n    }\n\n    event MessageSent(\n        address indexed sender,\n        uint256 srcChainID,\n        bytes32 receiver,\n        uint256 indexed dstChainId,\n        bytes message,\n        uint64 indexed nonce,\n        bytes options,\n        uint256 fee\n    );\n\n    function estimateFee(uint256 _dstChainId, bytes calldata _options)\n        public\n        returns (uint256)\n    {\n        uint256 fee = IGasFeePricing(gasFeePricing).estimateGasFee(\n            _dstChainId,\n            _options\n        );\n        require(fee != 0, \"Fee not set\");\n        return fee;\n    }\n\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable {\n        require(_dstChainId != block.chainid, \"Invalid chainId\");\n        uint256 fee = estimateFee(_dstChainId, _options);\n        require(msg.value >= fee, \"Insuffient gas fee\");\n        emit MessageSent(\n            msg.sender,\n            block.chainid,\n            _receiver,\n            _dstChainId,\n            _message,\n            nonce,\n            _options,\n            msg.value\n        );\n        fees += msg.value;\n        ++nonce;\n    }\n\n    /**\n     * @notice Withdraws accumulated fees in native gas token, based on fees variable.\n     * @param to Address to withdraw gas fees to, which can be specified in the event owner() can't receive native gas\n     */\n    function withdrawGasFees(address payable to) external onlyOwner {\n        uint256 withdrawAmount = fees;\n        // Reset fees to 0\n        to.transfer(withdrawAmount);\n        delete fees;\n    }\n}\n"
    },
    "contracts/messaging/MessageBusReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-4.5.0/access/Ownable.sol\";\nimport \"./interfaces/IAuthVerifier.sol\";\nimport \"./interfaces/ISynMessagingReceiver.sol\";\n\ncontract MessageBusReceiver is Ownable {\n    address public authVerifier;\n\n    enum TxStatus {\n        Null,\n        Success,\n        Fail,\n        Retry\n    }\n\n    // Store all successfully executed messages\n    mapping(bytes32 => TxStatus) executedMessages;\n\n    // TODO: Rename to follow one standard convention -> Send -> Receive?\n    event Executed(\n        bytes32 msgId,\n        TxStatus status,\n        address indexed _dstAddress,\n        uint64 srcChainId,\n        uint64 srcNonce\n    );\n    event NeedRetry(bytes32 indexed msgId, uint64 srcChainId, uint64 srcNonce);\n    event CallReverted(string reason);\n\n    constructor(address _authVerifier) {\n        authVerifier = _authVerifier;\n    }\n\n    function computeMessageId(\n        uint256 _srcChainId,\n        bytes32 _srcAddress,\n        address _dstAddress,\n        uint256 _nonce,\n        bytes calldata _message\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _srcChainId,\n                    _srcAddress,\n                    block.chainid,\n                    _dstAddress,\n                    _nonce,\n                    _message\n                )\n            );\n    }\n\n    function getExecutedMessage(bytes32 _messageId)\n        external\n        view\n        returns (TxStatus)\n    {\n        return executedMessages[_messageId];\n    }\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver\n     based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes32 address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes32 _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external {\n        // In order to guarentee that an individual message is only executed once, a messageId is generated.\n        bytes32 messageId = computeMessageId(\n            _srcChainId,\n            _srcAddress,\n            _dstAddress,\n            _nonce,\n            _message\n        );\n        require(messageId == _messageId, \"Incorrect messageId submitted\");\n        // enforce that this message ID hasn't already been tried ever\n        // console.log(uint256(executedMessages[messageId]));\n        require(\n            executedMessages[messageId] == TxStatus.Null,\n            \"Message already executed\"\n        );\n        // Authenticate executeMessage, will revert if not authenticated\n        IAuthVerifier(authVerifier).msgAuth(abi.encode(msg.sender));\n        // Message is now in-flight, adjust status\n        // executedMessages[messageId] = TxStatus.Pending;\n\n        TxStatus status;\n        try\n            ISynMessagingReceiver(_dstAddress).executeMessage{gas: _gasLimit}(\n                _srcAddress,\n                _srcChainId,\n                _message,\n                msg.sender\n            )\n        returns (ISynMessagingReceiver.MsgExecutionStatus execStatus) {\n            // TODO: This state is not fully managed yet - May not even need return variables.\n            if (execStatus == ISynMessagingReceiver.MsgExecutionStatus.Retry) {\n                // handle permissionless retries or delete and only allow Success / Revert\n                executedMessages[messageId] = TxStatus.Null;\n                emit NeedRetry(messageId, uint64(_srcChainId), uint64(_nonce));\n            } else {\n                // Currently assuming success state if no returned variable & no revert?\n                status = TxStatus.Success;\n            }\n        } catch (bytes memory reason) {\n            // call hard reverted & failed\n            emit CallReverted(getRevertMsg(reason));\n            status = TxStatus.Fail;\n        }\n\n        executedMessages[messageId] = status;\n        emit Executed(\n            messageId,\n            status,\n            _dstAddress,\n            uint64(_srcChainId),\n            uint64(_nonce)\n        );\n    }\n\n    /** HELPER VIEW FUNCTION */\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData)\n        private\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /** CONTRACT CONFIG */\n\n    function updateMessageStatus(bytes32 _messageId, TxStatus _status)\n        public\n        onlyOwner\n    {\n        executedMessages[_messageId] = _status;\n    }\n\n    function updateAuthVerifier(address _authVerifier) public onlyOwner {\n        require(_authVerifier != address(0), \"Cannot set to 0\");\n        authVerifier = _authVerifier;\n    }\n}\n"
    },
    "@openzeppelin/contracts-4.5.0/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/messaging/interfaces/IGasFeePricing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IGasFeePricing {\n    \n    /**\n     * @notice Permissioned method to allow an off-chain party to set what each dstChain's\n     * gas cost is priced in the srcChain's native gas currency. \n     * Example: call on ETH, setCostPerChain(43114, 30000000000, 25180000000000000)\n     * chain ID 43114\n     * Average of 30 gwei cost to transaction on 43114\n     * AVAX/ETH = 0.02518, scaled to gas in wei = 25180000000000000\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _gasUnitPrice The estimated current gas price in wei of the destination chain\n     * @param _gasTokenPriceRatio Gas ratio of dstGasToken / srcGasToken\n     */\n    function setCostPerChain(uint256 _dstChainId, uint256 _gasUnitPrice, uint256 _gasTokenPriceRatio) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateGasFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n}  "
    },
    "contracts/messaging/interfaces/IAuthVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IAuthVerifier {\n    /**\n     * @notice Authentication library to allow the validator network to execute cross-chain messages.\n     * @param _authData A bytes32 address encoded via abi.encode(address)\n     * @return authenticated returns true if bytes data submitted and decoded to the address is correct\n     */\n    function msgAuth(bytes calldata _authData)\n        external\n        view\n        returns (bool authenticated);\n\n    /**\n     * @notice Permissioned method to support upgrades to the library\n     * @param _nodegroup address which has authentication to execute messages\n     */\n    function setNodeGroup(address _nodegroup) external;\n}"
    },
    "contracts/messaging/interfaces/ISynMessagingReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ISynMessagingReceiver {\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 => bytes32) internal trustedRemoteLookup;\n\n\n    /** \n     * @notice MsgExecutionStatus state\n     * @return Success execution succeeded, finalized\n     * @return Fail // execution failed, finalized\n     * @return Retry // execution failed or rejected, set to be retryable\n    */ \n    enum MsgExecutionStatus {\n        Success, \n        Fail,\n        Retry\n    }\n\n     /**\n     * @notice Called by MessageBus \n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external returns (MsgExecutionStatus);\n}\n    "
    },
    "contracts/messaging/GasFeePricing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-4.5.0/access/Ownable.sol\";\n\ncontract GasFeePricing is Ownable {\n    // DstChainId => The estimated current gas price in wei of the destination chain\n    mapping(uint256 => uint256) public dstGasPriceInWei;\n    // DstChainId => USD gas ratio of dstGasToken / srcGasToken\n    mapping(uint256 => uint256) public dstGasTokenRatio;\n\n    constructor() {}\n\n    /**\n     * @notice Permissioned method to allow an off-chain party to set what each dstChain's\n     * gas cost is priced in the srcChain's native gas currency.\n     * Example: call on ETH, setCostPerChain(43114, 30000000000, 25180000000000000)\n     * chain ID 43114\n     * Average of 30 gwei cost to transaction on 43114\n     * AVAX/ETH = 0.02518, scaled to gas in wei = 25180000000000000\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _gasUnitPrice The estimated current gas price in wei of the destination chain\n     * @param _gasTokenPriceRatio USD gas ratio of dstGasToken / srcGasToken\n     */\n    function setCostPerChain(\n        uint256 _dstChainId,\n        uint256 _gasUnitPrice,\n        uint256 _gasTokenPriceRatio\n    ) external onlyOwner {\n        dstGasPriceInWei[_dstChainId] = _gasUnitPrice;\n        dstGasTokenRatio[_dstChainId] = _gasTokenPriceRatio;\n    }\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateGasFee(uint256 _dstChainId, bytes memory _options)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasLimit;\n        // temporary gas limit set\n        if (_options.length != 0) {\n            (\n                uint16 txType,\n                uint256 gasLimit,\n                uint256 dstAirdrop,\n                bytes32 dstAddress\n            ) = decodeOptions(_options);\n        } else {\n            gasLimit = 200000;\n        }\n\n        uint256 minFee = ((dstGasPriceInWei[_dstChainId] *\n            dstGasTokenRatio[_dstChainId] *\n            gasLimit) / 10**18);\n\n        return minFee;\n    }\n\n    function encodeOptions(uint16 txType, uint256 gasLimit)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(txType, gasLimit);\n    }\n\n    function encodeOptions(\n        uint16 txType,\n        uint256 gasLimit,\n        uint256 dstNativeAmt,\n        bytes32 dstAddress\n    ) public pure returns (bytes memory) {\n        return abi.encodePacked(txType, gasLimit, dstNativeAmt, dstAddress);\n    }\n\n    function decodeOptions(bytes memory _options)\n        public\n        pure\n        returns (\n            uint16,\n            uint256,\n            uint256,\n            bytes32\n        )\n    {\n        // decoding the _options - reverts if type 2 and there is no dstNativeAddress\n        require(\n            _options.length == 34 || _options.length > 66,\n            \"Wrong _adapterParameters size\"\n        );\n        uint16 txType;\n        uint256 gasLimit;\n        uint256 dstNativeAmt;\n        bytes32 dstNativeAddress;\n        assembly {\n            txType := mload(add(_options, 2))\n            gasLimit := mload(add(_options, 34))\n        }\n\n        if (txType == 2) {\n            assembly {\n                dstNativeAmt := mload(add(_options, 66))\n                dstNativeAddress := mload(add(_options, 98))\n            }\n            require(dstNativeAmt != 0, \"dstNativeAmt empty\");\n            require(dstNativeAddress != bytes32(0), \"dstNativeAddress empty\");\n        }\n\n        return (txType, gasLimit, dstNativeAmt, dstNativeAddress);\n    }\n}\n"
    },
    "contracts/messaging/dfk/bridge/HeroBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../../framework/SynMessagingReceiver.sol\";\nimport \"../IHeroCoreUpgradeable.sol\";\nimport \"../IAssistingAuctionUpgradeable.sol\";\nimport {HeroStatus} from \"../types/HeroTypes.sol\";\n\npragma solidity 0.8.13;\n\n/** @title Core app for handling cross chain messaging passing to bridge Hero NFTs\n */\n\ncontract HeroBridge is SynMessagingReceiver {\n    address public heroes;\n    address public assistingAuction;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        Hero dstHero;\n        address dstUser;\n        uint256 dstHeroId;\n    }\n\n    constructor(\n        address _messageBus,\n        address _heroes,\n        address _assistingAuction\n    ) {\n        messageBus = _messageBus;\n        heroes = _heroes;\n        assistingAuction = _assistingAuction;\n    }\n\n\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4) { \n        return this.onERC721Received.selector;\n    }\n\n    function _createMessage(\n        uint256 _heroId,\n        address _dstUserAddress,\n        Hero memory _heroToBridge\n    ) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({\n            dstHeroId: _heroId,\n            dstHero: _heroToBridge,\n            dstUser: _dstUserAddress\n        });\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message)\n        internal\n        pure\n        returns (MessageFormat memory)\n    {\n        MessageFormat memory decodedMessage = abi.decode(\n            _message,\n            (MessageFormat)\n        );\n        return decodedMessage;\n    }\n\n    function _createOptions() public returns (bytes memory) {\n        abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    /**\n     * @notice User must have an existing hero minted to bridge it.\n     * @param _heroId specifics which hero msg.sender already holds and will transfer to the bridge contract\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     */\n    function sendHero(uint256 _heroId, uint256 _dstChainId) external payable {\n        Hero memory heroToBridge = IHeroCoreUpgradeable(heroes).getHero(\n            _heroId\n        );\n        bytes32 receiver = trustedRemoteLookup[_dstChainId];\n        // _createMessage(heroId, dstUserAddress, Hero);\n        bytes memory msgToPass = _createMessage(\n            _heroId,\n            msg.sender,\n            heroToBridge\n        );\n        // Create _options\n        // temporarily empty\n        bytes memory options = _createOptions();\n\n        // revert if the hero is on a quest\n        require(\n            heroToBridge.state.currentQuest == address(0),\n            \"hero is questing\"\n        );\n\n        // revert if the hero is on auction\n        require(\n            !IAssistingAuction(assistingAuction).isOnAuction(_heroId),\n            \"assisting auction\"\n        );\n\n        IHeroCoreUpgradeable(heroes).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _heroId\n        );\n        // Hero now locked, message can be safely emitted\n\n        _send(receiver, _dstChainId, msgToPass, options);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the hero bridge mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override returns (MsgExecutionStatus) {\n        // Decode _message, depending on exactly how the originating message is structured\n        /** \n            Message data: \n                Hero memory heroToBridge = IHeroCoreUpgradeable(heroes).getHero(_heroId);\n                address dstUserAddress = msg.sender;\n                uint256 dstHeroId = _heroId;\n             */\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n\n        Hero memory dstHero = passedMsg.dstHero;\n        address dstUser = passedMsg.dstUser;\n        uint256 dstHeroId = passedMsg.dstHeroId;\n\n        // will revert if non-existant Hero\n        try IHeroCoreUpgradeable(heroes).ownerOf(dstHeroId) returns (\n            address heroOwner\n        ) {\n            /** \n                If heroId does exist (which means it should be locked on this contract), as it was bridged before.\n                Transfer it to message.dstUserAddress\n                */\n\n            if (heroOwner == address(this)) {\n                IHeroCoreUpgradeable(heroes).safeTransferFrom(\n                    address(this),\n                    dstUser,\n                    dstHeroId\n                );\n            }\n        } catch {\n            /** \n                If hero ID doesn't exist: \n                Mint a hero to msg.dstUserAddress\n                */\n            IHeroCoreUpgradeable(heroes).bridgeMint(dstHero, dstUser);\n        }\n\n        // update the hero attributes based on the attributes in the message (Assumes the message has more recent attributes)\n        IHeroCoreUpgradeable(heroes).updateHero(dstHero);\n        // Tx completed, return Success\n        return MsgExecutionStatus.Success;\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) internal override {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0));\n        require(trustedRemoteLookup[_dstChainId] == _receiver);\n        IMessageBus(messageBus).sendMessage{value: msg.value}(\n            _receiver,\n            _dstChainId,\n            _message,\n            _options\n        );\n    }\n\n    function setAssistingAuctionAddress(address _assistingAuction) external onlyOwner {\n        assistingAuction = _assistingAuction;\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n"
    },
    "contracts/messaging/framework/SynMessagingReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"../interfaces/ISynMessagingReceiver.sol\";\nimport \"../interfaces/IMessageBus.sol\";\nimport \"@openzeppelin/contracts-4.5.0/access/Ownable.sol\";\n\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    \n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 => bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug & sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     * @return status Enum containing options of Success, Fail, Retry\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external returns (MsgExecutionStatus) {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        return _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor) internal virtual returns (MsgExecutionStatus);\n\n\n    function _send(bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options) internal virtual {\n            require(trustedRemoteLookup[_dstChainId] != bytes32(0));\n            IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n     // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n\n}\n"
    },
    "contracts/messaging/dfk/IHeroCoreUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Hero, HeroInfo, HeroState, SummoningInfo, HeroProfessions, Rarity} from \"./types/HeroTypes.sol\";\nimport {HeroCrystal} from \"./types/CrystalTypes.sol\";\n\ninterface IHeroCoreUpgradeable {\n    // NOT FINAL \n    function bridgeMint(Hero memory _hero, address dstAddress) external;\n    \n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n    function MINTER_ROLE() external view returns (bytes32);\n\n    function MODERATOR_ROLE() external view returns (bytes32);\n\n    function PAUSER_ROLE() external view returns (bytes32);\n\n    function STAMINA_ROLE() external view returns (bytes32);\n\n    function HERO_MODERATOR_ROLE() external view returns (bytes32);\n\n    function updateHero(Hero memory _hero) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function assistingAuction() external view returns (address);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function baseCooldown() external view returns (uint256);\n\n    function baseSummonFee() external view returns (uint256);\n\n    function burn(uint256 tokenId) external;\n\n    function calculateSummoningCost(uint256 _heroId) external view returns (uint256);\n\n    function cooldownPerGen() external view returns (uint256);\n\n    function cooldownPerSummon() external view returns (uint256);\n\n    function cooldowns(uint256) external view returns (uint32);\n\n    function createAssistingAuction(\n        uint256 _heroId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    ) external;\n\n    function createHero(\n        uint256 _statGenes,\n        uint256 _visualGenes,\n        Rarity _rarity,\n        bool _shiny,\n        HeroCrystal memory _crystal,\n        uint256 _crystalId\n    ) external returns (uint256);\n\n    function createSaleAuction(\n        uint256 _heroId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    ) external;\n\n    function deductStamina(uint256 _heroId, uint256 _staminaDeduction) external;\n\n    function extractNumber(\n        uint256 randomNumber,\n        uint256 digits,\n        uint256 offset\n    ) external pure returns (uint256 result);\n\n    function geneScience() external view returns (address);\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getCurrentStamina(uint256 _heroId) external view returns (uint256);\n\n    function getHero(uint256 _id) external view returns (Hero memory);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function increasePerGen() external view returns (uint256);\n\n    function increasePerSummon() external view returns (uint256);\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) external;\n\n    function initialize(address _crystalAddress) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function isReadyToSummon(uint256 _heroId) external view returns (bool);\n\n    function crystalToken() external view returns (address);\n\n    function mint(address to) external;\n\n    function name() external view returns (string memory);\n\n    function openCrystal(uint256 _crystalId) external returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function pause() external;\n\n    function paused() external view returns (bool);\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) external;\n\n    function saleAuction() external view returns (address);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function setAssistingAuctionAddress(address _address) external;\n\n    function setFees(address[] memory _feeAddresses, uint256[] memory _feePercents) external;\n\n    function setSaleAuctionAddress(address _address) external;\n\n    function setSummonCooldowns(\n        uint256 _baseCooldown,\n        uint256 _cooldownPerSummon,\n        uint256 _cooldownPerGen\n    ) external;\n\n    function setSummonFees(\n        uint256 _baseSummonFee,\n        uint256 _increasePerSummon,\n        uint256 _increasePerGen\n    ) external;\n\n    function setTimePerStamina(uint256 _timePerStamina) external;\n\n    function summonCrystal(\n        uint256 _summonerId,\n        uint256 _assistantId,\n        uint8 _summonerTears,\n        uint8 _assistantTears,\n        address _enhancementStone\n    ) external;\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function timePerStamina() external view returns (uint256);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function unpause() external;\n\n    function vrf(uint256 blockNumber) external view returns (bytes32 result);\n}\n"
    },
    "contracts/messaging/dfk/IAssistingAuctionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAssistingAuction {\n    function bid(uint256 _tokenId, uint256 _bidAmount) external;\n\n    function bidFor(\n        address _bidder,\n        uint256 _tokenId,\n        uint256 _bidAmount\n    ) external;\n\n    function cancelAuction(uint256 _tokenId) external;\n\n    function cancelAuctionWhenPaused(uint256 _tokenId) external;\n\n    function isOnAuction(uint256 _tokenId) external returns (bool);\n\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    ) external;\n\n    function getAuction(uint256 _tokenId)\n        external\n        view\n        returns (\n            address seller,\n            uint256 startingPrice,\n            uint256 endingPrice,\n            uint256 duration,\n            uint256 startedAt\n        );\n\n    function getCurrentPrice(uint256 _tokenId) external view returns (uint256);\n\n    function heroCore() external view returns (address);\n\n    function jewelToken() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function ownerCut() external view returns (uint256);\n\n    function paused() external view returns (bool);\n\n    function renounceOwnership() external;\n\n    function setFees(address[] memory _feeAddresses, uint256[] memory _feePercents) external;\n\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/messaging/dfk/types/HeroTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nenum HeroStatus {\n    OK,\n    KO\n}\n\nenum Rarity {\n    COMMON,\n    UNCOMMON,\n    RARE,\n    LEGENDARY,\n    MYTHIC\n}\n\nstruct HeroStats {\n    uint16 strength;\n    uint16 agility;\n    uint16 intelligence;\n    uint16 wisdom;\n    uint16 luck;\n    uint16 vitality;\n    uint16 endurance;\n    uint16 dexterity;\n    uint16 hp;\n    uint16 mp;\n    uint16 stamina;\n}\n\nstruct HeroStatGrowth {\n    uint16 strength;\n    uint16 agility;\n    uint16 intelligence;\n    uint16 wisdom;\n    uint16 luck;\n    uint16 vitality;\n    uint16 endurance;\n    uint16 dexterity;\n    uint16 hpSm;\n    uint16 hpRg;\n    uint16 hpLg;\n    uint16 mpSm;\n    uint16 mpRg;\n    uint16 mpLg;\n}\n\nstruct SummoningInfo {\n    uint256 summonedTime;\n    // How long until the hero can participate in summoning again.\n    uint256 nextSummonTime;\n    uint256 summonerId;\n    uint256 assistantId;\n    // How many summons the hero has done.\n    uint32 summons;\n    // How many summons can the hero do max.\n    uint32 maxSummons;\n}\n\nstruct HeroInfo {\n    uint256 statGenes;\n    uint256 visualGenes;\n    Rarity rarity;\n    bool shiny;\n    uint16 generation;\n    uint32 firstName;\n    uint32 lastName;\n    uint8 shinyStyle;\n    uint8 class;\n    uint8 subClass;\n}\n\nstruct HeroState {\n    // The time the hero's stamina is full at.\n    uint256 staminaFullAt;\n    // The time the hero's hp is full at.\n    uint256 hpFullAt;\n    // The time the hero's mp is full at.\n    uint256 mpFullAt;\n    // The current level of the hero.\n    uint16 level;\n    // The current XP the hero has towards their next level.\n    uint64 xp;\n    // The current quest a hero is undertaking, if any.\n    address currentQuest;\n    // The skill points the hero can spend.\n    uint8 sp;\n    HeroStatus status;\n}\n\nstruct HeroProfessions {\n    uint16 mining;\n    uint16 gardening;\n    uint16 foraging;\n    uint16 fishing;\n}\n\n/// @dev The main Hero struct.\nstruct Hero {\n    uint256 id;\n    SummoningInfo summoningInfo;\n    HeroInfo info;\n    HeroState state;\n    HeroStats stats;\n    HeroStatGrowth primaryStatGrowth;\n    HeroStatGrowth secondaryStatGrowth;\n    HeroProfessions professions;\n}\n\n"
    },
    "contracts/messaging/interfaces/IMessageBus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IMessageBus {\n    \n    /**\n     * @notice Sends a message to a receiving contract address on another chain. \n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver\n     based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message\n    ) external;\n\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options)\n        external\n        returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(\n        address _account\n    ) external;\n\n\n\n}\n"
    },
    "contracts/messaging/dfk/types/CrystalTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nstruct HeroCrystal {\n    address owner;\n    uint256 summonerId;\n    uint256 assistantId;\n    uint16 generation;\n    uint256 createdBlock;\n    uint256 heroId;\n    uint8 summonerTears;\n    uint8 assistantTears;\n    address enhancementStone;\n    uint32 maxSummons;\n    uint32 firstName;\n    uint32 lastName;\n    uint8 shinyStyle;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}